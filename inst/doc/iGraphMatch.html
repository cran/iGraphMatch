<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>iGraphMatch: an R Package for the Analysis of Graph Matching</title>


<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">

div.csl-bib-body { }
div.csl-entry {
clear: both;
margin-bottom: 0em;
}
.hanging div.csl-entry {
margin-left:2em;
text-indent:-2em;
}
div.csl-left-margin {
min-width:2em;
float:left;
}
div.csl-right-inline {
margin-left:2em;
padding-left:1em;
}
div.csl-indent {
margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore"><code>iGraphMatch</code>: an R Package for the Analysis of Graph Matching</h1>



<div id="abstract" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Abstract</h1>
<p><code>iGraphMatch</code> is an R package developed for matching the corresponding vertices between two edge-correlated graphs.
The package covers three categories of prevalent graph matching algorithms including relaxation-based, percolation-based, and spectral-based, which are applicable to matching graphs under the most general settings: weighted directed graphs of different order and graphs of multiple layers with auxiliary graph matching techniques.
We provide versatile options to incorporate prior information in the form of seeds with or without noise and similarity scores.
We also implement an S4 class that overloads popular operations for matrices in R for efficient computation of sparse plus low-rank matrices, which is a common structure we can decompose the matrices into in the process of matching graphs.
In addition, <code>iGraphMatch</code> provides functions to summarize the graph matching results in terms of several evaluation measures and visualize the matching performance.
Finally, the package also enables the users to sample correlated random graph pairs from classic random graph models to generate data for simulations.
This paper illustrates the practical applications of the package to the analysis of graph matching by detailed examples using real data from social networks and bioinformatics.</p>
</div>
<div id="sec:intro" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Introduction</h1>
<p>The graph matching (GM) problem seeks to find an alignment between the vertex sets of graphs that best preserves common structure across graphs.
This is often posed as minimizing edge disagreements of two graphs over all alignments.
Formally, given <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span>, two adjacency matrices corresponding to two graphs <span class="math inline">\(G_1=(V_1, E_1)\)</span> and <span class="math inline">\(G_2=(V_2, E_2)\)</span>, the goal is to find
<span class="math display">\[\begin{align*}
    \mathop{\mathrm{argmin}}_{P\in\Pi}\lVert A-PBP^T \rVert_F^2
\end{align*}\]</span>
where <span class="math inline">\(\Pi\)</span> is the set of all permutation matrices.
GM has wide applications in diverse fields, such as pattern recognition (<span class="citation">Berg, Berg, and Malik (2005)</span>, <span class="citation">Caelli and Kosinov (2004)</span>, <span class="citation">Conte et al. (2004)</span>), machine learning (<span class="citation">Liu and Qiao (2012)</span>, <span class="citation">Cour, Srinivasan, and Shi (2007)</span>), bioinformatics (<span class="citation">Nabieva et al. (2005)</span>, <span class="citation">Ito et al. (2001)</span>), neuroscience (<span class="citation">Chen et al. (2015)</span>), social network analysis (<span class="citation">Narayanan and Shmatikov (2009)</span>), and knowledge graph queries (<span class="citation">Hu et al. (2018)</span>).
More generally, the problem of discovering some true latent alignment between two networks can often be posed as variations on the above problem by adjusting the objective function for the setting.</p>
<p>The well-known graph isomorphism problem is a special case of GM problem when there exists a bijection between the nodes of two graphs which exactly preserves the edge structure.
In terms of computational complexity, GM is equivalent to the NP-hard quadratic assignment problem, which is considered a very challenging problem where few theoretical guarantees exist, even in special cases (<span class="citation">Finke, Burkard, and Rendl (1987)</span>).
For certain problems where the graphs are nearly isomorphic, polynomial-time algorithms do exist (<span class="citation">Aflalo, Bronstein, and Kimmel (2015a)</span>, <span class="citation">Umeyama (1988)</span>) but these methods frequently break down for more challenging instances.</p>
<p>This paper presents the detailed functionality of the <code>iGraphMatch</code> R package which serves as a practical tool for the use of prevalent graph matching methodologies.
These algorithms utilize either the spectral embedding of vertices (<span class="citation">Umeyama (1988)</span>), or relaxations of the objective function (<span class="citation">Zaslavskiy, Bach, and Vert (2009)</span>, <span class="citation">V. Lyzinski et al. (2016)</span>), or apply ideas from percolation theory (<span class="citation">Yartseva and Grossglauser (2013)</span>, <span class="citation">Kazemi, Hamed Hassani, and Grossglauser (2015)</span>).
The <code>iGraphMatch</code> package provides versatile options of working with graphs in the form of matrices, igraph objects or lists of either, and matching graphs under a generalized setting: weighted, directed, graphs of a different order, and multilayer graphs.</p>
<p>In addition, the <code>iGraphMatch</code> package incorporates prior information: seeds and similarities for all the implemented algorithms.
Seeds, or anchors, refer to partial knowledge of the alignment of two graphs.
In practice, seeds can be users with the same name and location across different social networks or pairs of genes with the same DNA sequences.
Some algorithms like the percolation algorithm (<span class="citation">Yartseva and Grossglauser (2013)</span>, <span class="citation">Kazemi, Hamed Hassani, and Grossglauser (2015)</span>) which matches two graphs by propagating matching information to neighboring pairs require seeds to kick off.
All algorithms improve substantially by incorporating seeds and can achieve accurate matching in polynomial time (<span class="citation">Vince Lyzinski, Fishkind, and Priebe (2014)</span>).
Similarity scores are another commonly used prior which measures the similarity between pairs of nodes across the graphs.
In the bioinformatics area, BLAST similarity score is an example of similarity scores that plays an important role in aligning two PPI networks (<span class="citation">Singh, Xu, and Berger (2008)</span>).
Similarity scores are usually generated from nodal covariates that are observed in both networks (<span class="citation">Kelley et al. (2004)</span>, <span class="citation">Belongie, Malik, and Puzicha (2002)</span>).</p>
<p>While under many scenarios the availability of exact partial matches, or hard seeding, is not realistic and expensive, the package also enables utilizing noisy prior information.
Similarity scores incorporate uncertainty by assigning the pair of nodes with higher similarity scores a bigger chance to match.
Seeds with uncertainty and even error can still be handled by self-correcting graph matching algorithms like the <span class="smallcaps">Frank-Wolfe</span> algorithm initialized at the noisy partial matching, called soft seeding.
<span class="citation">Fang, Sussman, and Lyzinski (2018)</span> showed that the <span class="smallcaps">Frank-Wolfe</span> algorithm with soft seeding scheme converges quickly to the true alignment under the correlated Erds-R&#39;enyi model with high probability.
Thus, the original intractable problem is reduced to be solvable in polynomial time.</p>
<p>Although there exist some open source software and packages containing graph matching functionality, <code>iGraphMatch</code> package provides a centralized repository for common graph matching methodologies with flexibility, tools for developing graph matching problem methodology, as well as metrics for evaluating and tools for visualizing matching performance.
Among the alternative GM packages, the most relevant ones include
the <code>igraph</code> (<span class="citation">Csardi and Nepusz (2006)</span>) package which focuses on descriptive network analysis and graph visualization based on igraph objects and provides a single graph matching algorithm,
the <code>GraphM</code> (<span class="citation">Zaslavskiy, Bach, and Vert (2009)</span>) package which implements several GM algorithms proposed between 1999 and 2009 in C, and the
<code>Corbi</code> (<span class="citation">Huang, Wu, and Zhang (2013)</span>) R package which is particularly designed for studies in bioinformatics and <code>SpecMatch</code> (<span class="citation">Mateus et al. (2008)</span>) which only involves implementations of spectral embedding based GM algorithms and written in C/C++.
None of these packages provide the breadth of tools, flexibility, and ease-of-use provided by the <code>iGraphMatch</code> package.</p>
<p>The rest of this paper is organized as follows.
Section <a href="#sec:background">3</a> describes the theoretical representations of the implemented GM algorithms, correlated random graph models and evaluation metrics.
Section <a href="#sec:usage">4</a> discusses the functionality and usage of R functions in the package, illustrated on the synthetic correlated graph pairs.
Section <a href="#sec:example">5</a> presents more complex examples on real data with several functions involved in the analysis and section <a href="#sec:conclusion">6</a> gives guidelines on using different GM algorithms under different circumstances and concludes the paper.</p>
</div>
<div id="sec:background" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Graph matching background</h1>
<p>In this section, we give background on graph matching and related problems followed by descriptions of the principal algorithms implemented in <code>iGraphMatch</code>.
For simplicity, we state all the algorithms in the context of matching undirected, unweighted graphs with the same cardinality.
All algorithms can also be directly applied to directed and weighted graphs.
In the second subsection, we discuss the techniques for matching graphs with a different number of vertices along with other extensions.
To conclude the section, we introduce the statistical models for correlated networks and discuss measures for the goodness of matching.</p>
<p>For the remainder of this paper we use the following notation.
Let <span class="math inline">\(G_1=(V_1,E_1)\)</span> and <span class="math inline">\(G_2=(V_2,E_2)\)</span> denote two graphs with <span class="math inline">\(n\)</span> vertices.
Let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be their corresponding binary symmetric adjacency matrices.
In the setting of seeded graph matching, suppose without loss of generality, the first <span class="math inline">\(s\)</span> pairs of nodes are seeds for simplicity.
In <code>iGraphMatch</code>, much more flexible seed specifications are possible, which will be illustrated in examples for usage of the package in section <a href="#sec:usage">4</a>.
Accordingly, let <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> be partitioned as:
<span class="math display">\[\begin{equation} \label{eq:seed_blocks}
A=
\begin{bmatrix}
A_{11} &amp; A_{21}^T \\
A_{21} &amp; A_{22}
\end{bmatrix}\text{ and }
B=
\begin{bmatrix}
B_{11} &amp; B_{21}^T \\
B_{21} &amp; B_{22}
\end{bmatrix}
\end{equation}\]</span>
where <span class="math inline">\(A_{11}, B_{11}\in\{0, 1\}^{s\times s}\)</span> denote seed-to-seed adjacencies, <span class="math inline">\(A_{21}, B_{21}\in\{0, 1\}^{(n-s)\times s}\)</span> denote nonseed-to-seed adjacencies and <span class="math inline">\(A_{22}, B_{22}\in\{0, 1\}^{(n-s)\times (n-s)}\)</span> denote nonseed-to-nonseed adjacencies.
Let <span class="math inline">\(S\)</span> be an <span class="math inline">\(n\)</span>-by-<span class="math inline">\(n\)</span> real-valued matrix of similarity scores.
Let <span class="math inline">\(\Pi\)</span> be the set of all permutation matrices and <span class="math inline">\(\mathcal{D}\)</span> be the set of all doubly stochastic matrices.</p>
<div id="assignment-problems" class="section level3" number="3.0.1">
<h3><span class="header-section-number">3.0.1</span> Assignment problems</h3>
<p>Matching or assignment problems are core problems in combinatorial optimization and appear in numerous fields (<span class="citation">Burkard, Dell’Amico, and Martello (2009)</span>).
As we illustrate in Eq. <span class="math inline">\(\eqref{eq:ob_func}\)</span>, a general version of the graph matching problem is equivalent to the quadratic assignment problem (QAP).
Similarly, QAP is related to the linear assignment problem (LAP) which also plays a role in GM.
The LAP asks how to assign <span class="math inline">\(n\)</span> items (eg. workers or nodes in <span class="math inline">\(G_1\)</span>) to <span class="math inline">\(n\)</span> other items (eg. tasks or nodes in <span class="math inline">\(G_2\)</span>) with minimum cost.
Let <span class="math inline">\(C\)</span> denote an <span class="math inline">\({n\times n}\)</span> cost matrix, where <span class="math inline">\(C_{ij}\)</span> denotes the cost of matching <span class="math inline">\(i\)</span> to <span class="math inline">\(j\)</span>, then the LAP is to find
<span class="math display">\[\begin{equation} \label{eq:LAP}
\begin{aligned}
&amp; \mathop{\mathrm{argmin}}_{P\in \Pi}
&amp; \mathrm{trace}(C^TP)
\end{aligned}
\end{equation}\]</span>
LAP is solvable in <span class="math inline">\(O(n^3)\)</span> time and there are numerous exact and approximate methods for both general (<span class="citation">Jonker and Volgenant (1988)</span>, <span class="citation">Kuhn (1955)</span>) and special cases, such as sparse cost matrices (<span class="citation">Volgenant (1996)</span>).</p>
<p>The statement of QAP resembles LAP, except that the cost function is expressed as a quadratic function.
Given two <span class="math inline">\(n\text{-by-}n\)</span> matrices <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> which can represent flows between facilities and the distance between locations respectively, or the adjacency matrices of two unaligned graphs, the objective function for QAP is:
<span class="math display">\[\begin{equation}\label{eq:qap}
\mathop{\mathrm{argmin}}_{P\in \Pi}    \mathrm{trace}(APBP^T).
\end{equation}\]</span>
This problem is NP-hard (<span class="citation">Finke, Burkard, and Rendl (1987)</span>) leading to a core challenge for any graph matching approach.</p>
<p>As will be illustrated in the rest of the section, some matching algorithms reduce the graph matching problem to solving a LAP.
For these algorithms, we include similarity scores <span class="math inline">\(S\)</span> by adding an additional term <span class="math inline">\(\mathrm{trace}(S^TP)\)</span> to the reduced objective function.</p>
</div>
<div id="subsec:gm" class="section level2" number="3.1">
<h2><span class="header-section-number">3.1</span> Graph matching algorithms</h2>
<p>In the <code>iGraphMatch</code> package, we implement three types of prevalent GM algorithms.
The first group uses relaxations of the objective function, including convex, concave, and indefinite relaxations.
The second group consists of algorithms that apply ideas from percolation theory, where matching information is spread from an initial set of matched nodes.
The last group is based on the spectral embedding of vertices.</p>
<div id="relaxation-based-algorithms" class="section level3" number="3.1.1">
<h3><span class="header-section-number">3.1.1</span> Relaxation-based algorithms</h3>
<p>These approaches relax the constraint that <span class="math inline">\(P\)</span> is a permutation matrix to require only that <span class="math inline">\(P\)</span> is doubly stochastic, optimizing over <span class="math inline">\(\mathcal{D}\)</span>, the convex hull of <span class="math inline">\(\Pi\)</span>.
When <span class="math inline">\(P\)</span> is a permutation matrix
<span class="math display">\[\begin{equation}
\label{eq:ob_func}
    \lVert A-PBP^T \rVert_F^2 = \lVert AP-PB \rVert_F^2 = \lVert A \rVert_F^2 + \lVert B \rVert_F^2 - 2\cdot \mathrm{trace}APBP^T.
\end{equation}\]</span>
However, these equalities do not hold for all <span class="math inline">\(P\in \mathcal{D}\)</span>, leading to different relaxations.</p>
<p>The second term of Eq.<span class="math inline">\(\eqref{eq:ob_func}\)</span> is a convex function and optimizing it over <span class="math inline">\(P\in\mathcal{D}\)</span> gives the convex relaxation, where the gradient at <span class="math inline">\(P\)</span> to the convex relaxed objective function is <span class="math inline">\(-4 APB + 2A^TAP + 2PBB^T\)</span>.
The last equality in Eq. <span class="math inline">\(\eqref{eq:ob_func}\)</span> shows that minimizing edge disagreements is equivalent to maximizing the number of edge agreements, <span class="math inline">\(\mathrm{trace} APBP^T\)</span>, a QAP.
Optimizing the indefinite function over <span class="math inline">\(\mathcal{D}\)</span> gives the indefinite relaxation with gradient <span class="math inline">\(-2APB\)</span> (<span class="citation">V. Lyzinski et al. (2016)</span>).</p>
<table style="width:100%;">
<caption><span id="tab:relaxation">Table 3.1: </span> Summary of relaxation methods for graph matching problem.</caption>
<colgroup>
<col width="12%" />
<col width="19%" />
<col width="16%" />
<col width="14%" />
<col width="19%" />
<col width="17%" />
</colgroup>
<thead>
<tr class="header">
<th>Relaxation</th>
<th>Objective Function</th>
<th>Domain</th>
<th>GM Algorithm</th>
<th>Optimization Guarantee</th>
<th>Optimum Form</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>None</td>
<td><span class="math inline">\(\lVert A-PBP^T \rVert_F^2\)</span></td>
<td><span class="math inline">\(\Pi\)</span></td>
<td>NA</td>
<td></td>
<td><span class="math inline">\(\Pi\)</span></td>
</tr>
<tr class="even">
<td>Indefinite</td>
<td><span class="math inline">\(\mathrm{tr}ADBD^T\)</span></td>
<td><span class="math inline">\(\mathcal{D}\)</span></td>
<td><span class="smallcaps">FW</span></td>
<td>Local</td>
<td><span class="math inline">\(\mathcal{D}\)</span> (often <span class="math inline">\(\Pi\)</span>)</td>
</tr>
<tr class="odd">
<td>Convex</td>
<td><span class="math inline">\(\lVert AD-DB \rVert_F^2\)</span></td>
<td><span class="math inline">\(\mathcal{D}\)</span></td>
<td><span class="smallcaps">FW, PATH</span></td>
<td>Global</td>
<td><span class="math inline">\(\mathcal{D}\)</span></td>
</tr>
<tr class="even">
<td>Concave</td>
<td><span class="math inline">\(-\mathrm{tr}(\Delta D)-2\mathrm{tr}(L_1^T D L_2 D^T)\)</span></td>
<td><span class="math inline">\(\mathcal{D}\)</span></td>
<td><span class="smallcaps">PATH</span></td>
<td>Local</td>
<td><span class="math inline">\(\Pi\)</span></td>
</tr>
</tbody>
</table>
<p>Generally, the convex relaxation leads to a solution that is not guaranteed to be near the solution to the original GM.
However, <span class="citation">Aflalo, Bronstein, and Kimmel (2015a)</span> introduced the class of “friendly” graphs based on the spectral properties of the adjacency matrices to characterize the applicability of the convex relaxation.
Matching two friendly graphs by using the convex relaxation is guaranteed to find the exact solution to the GM problem.
Unfortunately, this class is quite limiting and does not hold for most statistical models or real-world examples.</p>
<p>Another relaxation is the concave relaxation used in the PATH algorithm (<span class="citation">Zaslavskiy, Bach, and Vert (2009)</span>).
The concave relaxation uses the Laplacian matrix defined as <span class="math inline">\(L=D-A\)</span>, where <span class="math inline">\(D\)</span> is the diagonal degree matrix with diagonal entries <span class="math inline">\(D_{ii}=\sum_{i=1}^N A_{ij}\)</span>.
Assume <span class="math inline">\(L_i\)</span> and <span class="math inline">\(D_i\)</span>, <span class="math inline">\(i=1,2\)</span>, are the Laplacian matrices and degree matrices for <span class="math inline">\(G_1\)</span> and <span class="math inline">\(G_2\)</span> respectively, then we can rewrite the objective function as
<span class="math display">\[\begin{equation} \label{eq:concave}
\begin{split}
    \lVert A-PBP^T\rVert_F^2 &amp; = \lVert AP-PB \rVert_F^2\\
    &amp; = \lVert (D_1P-PD_2)-(L_1P-PL_2)\rVert_F^2\\
    &amp; = -\mathrm{trace}(\Delta P)+\mathrm{trace}(L_1^2)+\mathrm{trace}(L_2^2)-2\mathrm{trace}(L_1^T P L_2 P^T),
\end{split}
\end{equation}\]</span>
where the matrix <span class="math inline">\(\Delta_{ij}=(D_{2_{jj}}-D_{1_{ii}})^2\)</span>.
Dropping the terms not dependent on <span class="math inline">\(P\)</span> in equation <span class="math inline">\(\ref{eq:concave}\)</span>, we obtain the concave function <span class="math inline">\(-\mathrm{trace}(\Delta P)-2\mathrm{trace}(L_1^T P L_2 P^T)\)</span> on <span class="math inline">\(\mathcal{D}\)</span>.</p>
<p>A summary of the different relaxations is provided in Table <span class="math inline">\(\ref{tab:relaxation}\)</span>.
Relaxing the discrete problem to a continuous problem breaks the equivalence to the original formulation of the edge disagreement and enables employing algorithms based on gradient descent.</p>
<div id="frank-wolfe-methodology" class="section level4" number="3.1.1.1">
<h4><span class="header-section-number">3.1.1.1</span> <span class="smallcaps">Frank Wolfe</span> methodology</h4>
<p><span class="citation">V. Lyzinski et al. (2016)</span> introduced an algorithm for the relaxed graph matching problem, with each iteration computable in polynomial time, that can find local optima for the relaxations above.
The &lt;span style=“font-variant:small-caps;”&gt;Frank-Wolfe (FW)</span> (<span class="citation">Frank and Wolfe (1956)</span>) methodology is an iterative gradient ascent approach composed of two steps.
The first step finds an ascent direction that maximizes the gradient ascent.
In this case the ascent direction is a permutation matrix which is a vertex of the polytope of doubly stochastic matrices.
For the convex, indefinite, and concave relaxations, this corresponds to a LAP with the gradient as the cost function.
The second step performs a line search along the ascent direction to optimize the relaxed objective function.
As the objectives are all quadratic, this line search is simply requires optimizing a single-variable quadratic function along a line segment.
After the iterative algorithm converges, the final step of the procedure is to project the doubly stochastic matrix back to the set of permutation matrices, which is also a LAP.</p>
<p>The various relaxed forms can all serve as the objective function <span class="math inline">\(f(\cdot)\)</span> in the <span class="smallcaps">FW</span> Methodology, but in all cases a matrix <span class="math inline">\(D^0\in \mathcal{D}\)</span> must be chosen to initialize the procedure.
For the convex relaxation, the <span class="smallcaps">FW</span> methodology is guaranteed to converge to the global optimum regardless of the <span class="math inline">\(D^0\)</span>.
On the other hand, the <span class="smallcaps">FW</span> algorithm for the indefinite relaxation is not guaranteed to find a global optimum so the initialization is critical.</p>
<p>In many instances, the optimal solution to the convex relaxation lies in the interior of <span class="math inline">\(\mathcal{D}\)</span>.
This can lead to inaccurate solutions after the last projection step.
The local optima for the indefinite relaxation are often at extreme points of <span class="math inline">\(\mathcal{D}\)</span>, meaning the final projection often does nothing.</p>
<p>The default initialization for the indefinite problem is at the barycenter matrix, <span class="math inline">\(D^0 = \frac{1}{n}11^T\)</span>, but many other initialization procedures can be used.
These include randomized initializations, initializations based on similarity matrices, and initializing the indefinite relaxation at the interior point solution of the convex relaxation (<span class="citation">Aflalo, Bronstein, and Kimmel (2015b)</span>).
When prior information regarding a partial correspondence is known to be noisy, rather than incorporating this information as seeds, one can incorporate it as “soft” seeds which are used to generate the initialization (<span class="citation">Fang, Sussman, and Lyzinski (2018)</span>).</p>
<p>When prior information is available in the form of seeds,
the seeded graph matching problem (<span class="citation">Vince Lyzinski, Fishkind, and Priebe (2014)</span>) works on the objective function <span class="math inline">\(\ref{eq:ob_func}\)</span> with the permutation matrix <span class="math inline">\(P^{n\times n}\)</span> substituted by <span class="math inline">\(I_s\oplus P^{(n-s)\times (n-s)}\)</span>, the direct sum of an <span class="math inline">\(s\times s\)</span> identity matrix and an <span class="math inline">\((n-s)\times (n-s)\)</span> permutation matrix.</p>
<p>Employing the indefinite relaxed objective function incorporating seeds, we formulate the problem as finding
<span class="math display">\[\begin{align*}
    \hat{P} % &amp;= \argmin_{P\in \Pi} \mathrm{trace} A(I_s\oplus P)B(I_s\oplus P)^T \\
    &amp;= \mathop{\mathrm{argmax}}_{P\in\mathcal{D}} 2\cdot\mathrm{trace}P^TA_{21}B_{21}^T+\mathrm{trace}A_{22}PB_{22}P^T
\end{align*}\]</span>
where the gradient to the objective function is
<span class="math display">\[\begin{equation} \label{eq:sgm_gradient}
  \nabla f(P)=2\cdot A_{21}B_{21}^T+2\cdot A_{22}PB_{22}.
\end{equation}\]</span></p>
<p>In total, this uses the information between seeded nodes and nonseeded nodes and the nonseed-to-nonseed information.
Applying seeded graph matching to the convex relaxation and concave relaxation closely resembles the case of indefinite relaxation.</p>
</div>
<div id="path-algorithm" class="section level4" number="3.1.1.2">
<h4><span class="header-section-number">3.1.1.2</span> <span class="smallcaps">PATH</span> algorithm</h4>
<p><span class="citation">Zaslavskiy, Bach, and Vert (2009)</span> introduced a convex-concave programming approach to approximately solve the graph matching problem.
The concave relaxation has the same solution as the original graph matching problem.
The <span class="smallcaps">PATH</span> algorithm finds a local optimum to the concave relaxation by considering convex combinations of the convex relaxation <span class="math inline">\(F_0(P)\)</span> and the concave relaxation <span class="math inline">\(F_1(P)\)</span> denoted by <span class="math inline">\(F_{\lambda} =(1 - \lambda) F_0 + \lambda F_1\)</span>.
Starting from the solution to the convex relaxation (<span class="math inline">\(\lambda=0\)</span>) the algorithm iteratively performs gradient ascent using the FW methodology at <span class="math inline">\(F_\lambda\)</span>, increasing <span class="math inline">\(\lambda\)</span> after each iteration, until <span class="math inline">\(\lambda = 1\)</span>.</p>
</div>
</div>
<div id="percolation-based-algorithms" class="section level3" number="3.1.2">
<h3><span class="header-section-number">3.1.2</span> Percolation-based algorithms</h3>
<p>Under the <span class="smallcaps">FW</span> methodology, all the nodes admit a correspondence but the (relaxed) matching correspondence evolves through iterations.
On the other hand, percolation approaches start with a set of seeds, adding one new match at each iteration.
The new matches are fixed and hence not updated in future iterations.</p>
<p>Each iteration expands the set of matched nodes by propagating the current matching information to neighbors.
The guiding intuition is that more matched neighbors are an indicator of a more plausible match, an intuition analogous to the gradient ascent approaches above.
We will present two algorithms in this category where the <span class="smallcaps">ExpandWhenStuck</span> algorithm is an extension to the <span class="smallcaps">Percolation</span> algorithm.</p>
<p>There are some distinctions about the inputs and outputs of percolation methods compared to the above relaxation methods.</p>
<div id="percolation-algorithm" class="section level4" number="3.1.2.1">
<h4><span class="header-section-number">3.1.2.1</span> <span class="smallcaps">Percolation</span> Algorithm</h4>
<p><span class="citation">Yartseva and Grossglauser (2013)</span> provides a simple and fast approach to solve the graph matching problem by starting with a handful of seeds and propagating to the rest of the graphs.
At each iteration, the matching information up to the current iteration is encoded in a subpermutation matrix <span class="math inline">\(P\)</span> where <span class="math inline">\(P_{ij}=1\)</span> if <span class="math inline">\(i\)</span> is matched to <span class="math inline">\(j\)</span>, and <span class="math inline">\(0\)</span> otherwise.</p>
<p>The <span class="smallcaps">Percolation</span> algorithm searches for the most promising new match among the unmatched pairs through the mark matrix, <span class="math inline">\(M=APB\)</span>,
which is the gradient of the indefinite relaxation when extended to sub-doubly stochastic matrices.
When similarity scores are available, they are added to the mark matrix to combine topological structure and similarity scores.</p>
<p>Adopting analogous partitions on the adjacency matrices as in equation <span class="math inline">\(\eqref{eq:seed_blocks}\)</span>, we let <span class="math inline">\(A_{21}, B_{21}\)</span> denote sub-matrix corresponding to potential adjacencies between unmatched and matched nodes.
Since all the candidates of matched pairs are permanently removed from consideration, we need only consider <span class="math inline">\(M&#39;=A_{21}B_{21}^T\)</span>, the sub-matrix of <span class="math inline">\(M\)</span> corresponding to the unmatched nodes in both graphs.
As a result, the <span class="smallcaps">Percolation</span> algorithm only uses matched-to-unmatched information to generate new matches.</p>
<p>Moreover, the mark matrix <span class="math inline">\(M\)</span> can also be interpreted as encoding the number of matched neighboring pairs for each pair of nodes <span class="math inline">\(i\in V_1\)</span>, <span class="math inline">\(j\in V_2\)</span>.
Suppose <span class="math inline">\(u, u&#39;\in V_1\)</span>, <span class="math inline">\(v,v&#39;\in V_2\)</span>, <span class="math inline">\([u,u&#39;]\in E_1\)</span> and <span class="math inline">\([v,v&#39;]\in E_2\)</span>, then <span class="math inline">\((u&#39;,v&#39;)\)</span> is a neighboring pair of <span class="math inline">\((u,v)\)</span>.
In each iteration, while there remain unmatched nodes with more than <span class="math inline">\(r\)</span> matched neighboring pairs, the percolation algorithm matches the pair of nodes with the highest score <span class="math inline">\(M_{uv}\)</span>,<br />
and adds one mark to all the neighboring pairs of <span class="math inline">\((u,v)\)</span>.
Note that the algorithm may stop before all nodes are matched, leading to the return of a partial match.</p>
<p>There is only one tuning parameter in the <span class="smallcaps">Percolation</span> algorithm, the threshold <span class="math inline">\(r\)</span> which controls a tradeoff between quantity of matches and quality of matches.
With a small threshold, the algorithm has a larger chance of matching wrong pairs.
If <span class="math inline">\(r\)</span> is larger, then the algorithm might stop before matching many pairs (<span class="citation">Kazemi, Hamed Hassani, and Grossglauser (2015)</span>).</p>
<p>The <span class="smallcaps">Percolation</span> algorithm can be generalized to matching weighted graphs by making an adjustment to how we measure the matching information from the neighbors.
Since we prefer to match edges with smaller weight differences and higher absolute weights, we propose to adopt the following update formula for the score associated with each pair of nodes <span class="math inline">\((i,j)\)</span>:
<span class="math display">\[M_{ij}=M_{ij} + \sum_{u\in N(i)}\sum_{v\in N(j)}1-\frac{|w_{iu}-w_{jv}|}{\max(|w_{iu}|, |w_{jv}|)}.\]</span>
Thus, the score contributed by each neighboring pair of <span class="math inline">\((i,j)\)</span> is a number in <span class="math inline">\([0,1]\)</span>.</p>
</div>
<div id="expandwhenstuck-algorithm" class="section level4" number="3.1.2.2">
<h4><span class="header-section-number">3.1.2.2</span> <span class="smallcaps">ExpandWhenStuck</span> Algorithm</h4>
<p><span class="citation">Kazemi, Hamed Hassani, and Grossglauser (2015)</span> extends the <span class="smallcaps">Percolation</span> algorithm to a version that can operate with a smaller number of seeds.
Without enough seeds, when there are no more unmatched pairs with a score higher or equal to the threshold <span class="math inline">\(r\)</span>, the <span class="smallcaps">Percolation</span> algorithm would stop even if there are still unmatched pairs.
<span class="smallcaps">ExpandWhenStuck</span> uses all pairs of nodes with at least one matched neighboring pair, <span class="math inline">\(M_{ij}\geq 1\)</span>, as new seeds to restart the matching process by adding one mark to all of the new seeds’ neighboring pairs, without updating the matched set.
If the updated mark matrix consists of new pairs with marks greater or equal to <span class="math inline">\(r\)</span>, then the percolation algorithm continues, leading to larger matched sets.</p>
</div>
</div>
<div id="spectral-based-algorithm" class="section level3" number="3.1.3">
<h3><span class="header-section-number">3.1.3</span> Spectral-based algorithm</h3>
<p>Another class of graph matching algorithms uses the spectral properties of adjacency matrices.</p>
<div id="isorank-algorithm" class="section level4" number="3.1.3.1">
<h4><span class="header-section-number">3.1.3.1</span> <span class="smallcaps">IsoRank</span> Algorithm</h4>
<p><span class="citation">Singh, Xu, and Berger (2008)</span> propose the <span class="smallcaps">IsoRank</span> algorithm that uses neighboring topology and similarity scores and exploits spectral properties of the solution.
The <span class="smallcaps">IsoRank</span> algorithm is also based on the relaxation-based algorithms by encoding the topological structure of two graphs in <span class="math inline">\(ADB\)</span>, which is again proportional to the gradient of the indefinite relaxation.
However, the representations of each term of <span class="math inline">\(ADB\)</span> are slightly different.
<span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> are the column-wise normalized adjacency matrices and <span class="math inline">\(D\)</span> is not necessarily a doubly stochastic matrix yet <span class="math inline">\(D_{ij}\)</span> still indicates how promising it is to match <span class="math inline">\(i\in V_1\)</span> to <span class="math inline">\(j\in V_2\)</span>.</p>
<p>Similar to the idea of <span class="smallcaps">Percolation</span> algorithm, the intuition is that the impact of a pair of matched nodes is evenly distributed to all of their neighbors to propagate plausible matches.
This is achieved by solving the eigenvalue problem
<span class="math display">\[\begin{align}\label{eq:Iso1}
    \mathrm{vec}(D)=(A\otimes B) \mathrm{vec}(D),
\end{align}\]</span>
where <span class="math inline">\(\mathrm{vec}(D)\)</span> denotes the vectorization of matrix <span class="math inline">\(D\)</span>, and the right hand side is equivalent to <span class="math inline">\(ADB\)</span>.</p>
<p>To combine network-topological structure and similarity scores in the objective function, the normalized similarity score <span class="math inline">\(E\)</span> is added to the right hand side of Eq. <span class="math inline">\(\ref{eq:Iso1}\)</span>, where <span class="math inline">\(E=S/\|S\|_1\)</span>, and <span class="math inline">\(|\cdot|_1\)</span> denotes the L1 norm.</p>
<p>Note that when similarity score is not available as prior information, we can also construct a doubly stochastic similarity score matrix from seeds by taking <span class="math inline">\(I_{s\times s}\oplus \frac{1}{n-s}11_{(n-s)\times (n-s)}\)</span>.
To solve the eigenvalue problem <span class="math inline">\(\ref{eq:Iso1}\)</span>, we resort to the power method.
Finally, the global alignment is generated by a greedy algorithm or using the algorithms for solving the linear assignment problem (LAP).</p>
</div>
<div id="umeyama-algorithm" class="section level4" number="3.1.3.2">
<h4><span class="header-section-number">3.1.3.2</span> <span class="smallcaps">Umeyama</span> algorithm</h4>
<p><span class="citation">Umeyama (1988)</span> is a spectral approach to find approximate solutions to the graph matching problem.
Assuming eigendecompositions of adjacency matrices <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> as <span class="math inline">\(A=U_A\Lambda_AU_A^T\)</span> and <span class="math inline">\(B=U_B\Lambda_BU_B^T\)</span>, let <span class="math inline">\(|U_A|\)</span> and <span class="math inline">\(|U_B|\)</span> be matrices which takes absolute values of each element of <span class="math inline">\(U_A\)</span> and <span class="math inline">\(U_B\)</span>.
Such modification to the eigenvector matrices guarantees the uniqueness of eigenvector selection.
The global mapping is obtained by minimizing the differences between matched rows of <span class="math inline">\(U_A\)</span> and <span class="math inline">\(U_B\)</span>:
<span class="math display">\[\begin{align*}
    \hat{P}=\mathop{\mathop{\mathrm{argmin}}}_{P\in\Pi}\lVert |U_A|-P|U_B|\rVert_F=\mathop{\mathop{\mathrm{argmax}}}_{P\in\Pi}\mathrm{trace}(|U_B||U_A|^TP)
\end{align*}\]</span></p>
<p>The <span class="smallcaps">Umeyama</span> algorithm can be generalized to matching directed graphs by eigendecomposing the Hermitian matrices <span class="math inline">\(E_A\)</span> and <span class="math inline">\(E_B\)</span> derived from the asymmetric adjacency matrices of the directed graphs.
The Hermitian matrix for the adjacency matrix <span class="math inline">\(A\)</span> is defined as <span class="math inline">\(E_A=A_S+iA_N\)</span>, where <span class="math inline">\(A_S=(A+A^T)/2\)</span> is a symmetric matrix, <span class="math inline">\(A_N=(A-A^T)/2\)</span> is a skew-symmetric matrix and <span class="math inline">\(i\)</span> is the imaginary unit.
Similarly, we can define the Hermitian matrix for <span class="math inline">\(B\)</span>.
Assume the eigendecompositions of <span class="math inline">\(E_A\)</span> and <span class="math inline">\(E_B\)</span> as follows:
<span class="math display">\[\begin{align*}
    E_A=W_A\Gamma_AW_A^*, \quad  E_B=W_B\Gamma_BW_B^*
\end{align*}\]</span>
and we aim at searching for:
<span class="math display">\[\begin{align*}
    \hat{P}=\mathop{\mathop{\mathrm{argmax}}}_{P\in\Pi}\mathrm{trace}(|W_B||W_A|^TP)
\end{align*}\]</span>
Note that the <span class="smallcaps">Umeyama</span> algorithm works on the condition that two graphs are isomorphic or nearly isomorphic.</p>
</div>
</div>
</div>
<div id="auxiliary-graph-matching-tools" class="section level2" number="3.2">
<h2><span class="header-section-number">3.2</span> Auxiliary graph matching tools</h2>
<div id="centering-technique" class="section level3" number="3.2.1">
<h3><span class="header-section-number">3.2.1</span> Centering technique</h3>
<p>Instead of encoding the non-adjacencies by zeros in the adjacency matrices, the centering technique (<span class="citation">Sussman et al. (2018)</span>) assigns negative values to such edges.
The first approach is encoding non-adjacent node-pairs as <span class="math inline">\(-1\)</span> with centered adjacency matrices <span class="math inline">\(\tilde{A}=2A-\textbf{J}\)</span> and <span class="math inline">\(\tilde{B}=2B-\textbf{J}\)</span>, where <span class="math inline">\(\textbf{J}\)</span> is a matrix of all ones.
An alternative approach relies on modeling assumptions where the pair of graphs are correlated but do not share a global structure.
We match <span class="math inline">\(\tilde{A} = A-\Lambda_A\)</span> and <span class="math inline">\(\tilde{B} = B-\Lambda_B\)</span>, where <span class="math inline">\(\Lambda\)</span> is an <span class="math inline">\(n\text{-by-}n\)</span> matrix with <span class="math inline">\(ij\)</span>-th entry denoting an estimated marginal probability of an edge.
In general, <span class="math inline">\(\Lambda\)</span> is unknown but there are methods in the literature to estimate <span class="math inline">\(\Lambda\)</span>.</p>
<p>Matching centered graphs changes the rewards for matching edges, non-edges, and the penalties for mismatches.
Adapting the centering technique for the problem at hand can be used to find specific types of correspondences.
This can also be combined with constructing multilayer networks out of single layer networks to match according to multiple criteria (<span class="citation">Li and Sussman (2019)</span>, <span class="citation">Fan et al. (2020)</span>).
The centering technique can be applied to any of the implemented graph matching algorithm.
It is especially useful when padding graphs with differing numbers of vertices to distinguish isolated vertices from padded vertices.</p>
</div>
<div id="padding-graphs-of-different-orders" class="section level3" number="3.2.2">
<h3><span class="header-section-number">3.2.2</span> Padding graphs of different orders</h3>
<p>Until this section, we have been considering matching two graphs whose vertex sets are of the same cardinality.
However, matching graphs with different orders are commonly seen in real-world problems.</p>
<p>Suppose <span class="math inline">\(A\in\{0,1\}^{n\times n}\)</span> and <span class="math inline">\(B\in\{0,1\}^{n_c\times n_c}\)</span> with <span class="math inline">\(n_c&lt;n\)</span>.
One can then pad the smaller graph with extra vertices to match the order of the larger graph, <span class="math inline">\(\tilde{B}=B\oplus \textbf{0}_{n-n_c}\)</span> and match <span class="math inline">\(A\)</span> and <span class="math inline">\(\tilde{B}\)</span>.
Every implemented graph matching algorithm in the <code>iGraphMatch</code> package automatically handles input graphs with a different number of vertices using sparse padding with minimal memory impact.</p>
<p>Since the isolated vertices and the padded vertices share the same topological structure, it can be useful to center the original graphs first then pad the smaller graph in the same manner.
This approach serves to differentiate between isolated vertices the padded ones.
It’s theoretically verified that in the correlated graph model, the centered padding scheme is guaranteed to find the true correspondence between the nodes of <span class="math inline">\(G_1\)</span> and the induced subgraph of <span class="math inline">\(G_2\)</span> under mild conditions even if <span class="math inline">\(|V_1|\ll|V_2|\)</span>, but the true alignment is not guaranteed without centering (<span class="citation">Sussman et al. (2018)</span>).</p>
</div>
<div id="exploiting-sparse-and-low-rank-structure" class="section level3" number="3.2.3">
<h3><span class="header-section-number">3.2.3</span> Exploiting sparse and low-rank structure</h3>
<p>Many real-world graphs, especially large graphs, are often very sparse with <span class="math inline">\(o(n^2)\)</span> and often <span class="math inline">\(\theta(n)\)</span> edges.
This can increase the difficulty of the graph matching problem due to the fact that there are fewer potential edges to match, but sparse graphs also come with computational advantages.
We rely on <code>igraph</code> and <code>Matrix</code> for efficient storage of these structures as well as the efficient implementation of various matrix operations.
We also use the LAPMOD algorithm for sparse LAP problems (<span class="citation">Volgenant (1996)</span>) (see below).</p>
<p>Similarly, a low-rank structure appears in some of the procedures including starting at the rank-1 barycenter matrix and the different centering schemes.
Since low-rank matrices are generally not sparse and visa-versa we implemented the <code>splr</code> S4 class, standing for sparse plus low-rank matrices.
This class inherits from the <code>Matrix</code> class and includes slots for an <span class="math inline">\(n\times n\)</span> sparse matrix <code>x</code> and <span class="math inline">\(n\times d\)</span> dense matrices <code>a</code> and <code>b</code>, to represent matrices of the form <code>x + tcrossprod(a, b)</code>.
This class implements efficient methods for matrix multiplication and other operations that exploit the sparse and low-rank structure of the matrices.
Specifically, these methods often require only <span class="math inline">\(O(\|x\|_0) + O(nd)\)</span> storage as opposed to <span class="math inline">\(O(n^2)\)</span> required for densely stored matrices, and enjoy analogous computational advantages.
While users can also use these matrices explicitly, most use of them is automatic within functions such as <code>init_start</code> and <code>center_graph</code> and the matrices can largely be used interchangeably with other matrices.</p>
</div>
<div id="sssec:lap_methods" class="section level3" number="3.2.4">
<h3><span class="header-section-number">3.2.4</span> LAP methods</h3>
<p>Multiple graph matching methods include solving an LAP and so we have included multiple methods for solving LAPs into the package.
Specifically we implement the Jonker-Volgenant algorithm (<span class="citation">Jonker and Volgenant (1988)</span>) for dense cost matrices and the LAPMOD algorithm (<span class="citation">Volgenant (1996)</span>) for sparse cost matrices.
Both algorithms are implemented in C to provide improved performance.
The LAPMOD approach is typically advantageous when the number of non-zero entries is less than 50%.
We also depend on the <code>clue</code> package for the <code>solve_LSAP</code> function which implements the Hungarian algorithm (<span class="citation">Papadimitriou and Steiglitz (1998)</span>) for solving an LAP.
Each of these methods can be used independently of a specific graph matching method using the <code>do_lap</code> function.</p>
</div>
<div id="multi-layered-graph-matching" class="section level3" number="3.2.5">
<h3><span class="header-section-number">3.2.5</span> Multi-layered graph matching</h3>
<p>Frequently, networks edges may have categorical attributes and from these categories, we can construct multilayer graphs (<span class="citation">Kivelä et al. (2014)</span>), where each layer in the networks contains edges from specific categories.
For matching two multilayer graphs, the standard graph matching problem can be extended as <span class="math inline">\(\sum_{l=1}^{m}\|A^{(l)} - PB^{(l)}P^T\|_F^2\)</span> where <span class="math inline">\(m\)</span> denotes the number of categories and <span class="math inline">\(A^{(l)}, B^{(l)}\)</span> are the adjacency matrices for the <span class="math inline">\(l\)</span>th layers in each graph.
Note, we assume that the layers are aligned, so that layer <span class="math inline">\(l\)</span> corresponds to the same edge-types in both multi-layer networks.</p>
<p>For an <code>igraph</code> object, the function <code>split_igraph</code> can be used to convert a single object with categorical edge attributes into a list with each element only containing the edges with a specific attribute value.
The implemented algorithms can seamlessly match multi-layer graphs, which are encoded as a list of either <code>igraph</code> objects or <code>matrix</code>-like objects.
We also implemented a <code>matrixlist</code> S4 class that implements many standard matrix operations so that algorithms can be easily extended to work with multilayer networks.</p>
</div>
</div>
<div id="graph-models" class="section level2" number="3.3">
<h2><span class="header-section-number">3.3</span> Correlated random graph models</h2>
<p>The correlated model (<span class="citation">V. Lyzinski et al. (2016)</span>) is essential in the theoretical study of graph matching algorithms.
In a single graph, each edge is present in the graph independently with probability <span class="math inline">\(p\)</span>.
The correlated model provides a joint distribution for a pair of graphs, where each graph is marginally distributed as an graph and corresponding edge-pairs are correlated.</p>
<p>To sample a pair of correlated graphs with edge probability <span class="math inline">\(p\)</span>, and Pearson correlation <span class="math inline">\(\rho\)</span>, we first sample three independent graphs <span class="math inline">\(G_1\)</span>, <span class="math inline">\(Z_0\)</span> and <span class="math inline">\(Z_1\)</span> with edge probabilities <span class="math inline">\(p\)</span>, <span class="math inline">\(p(1-\rho)\)</span> and <span class="math inline">\(p+\rho(1-p)\)</span> respectively.
Let <span class="math inline">\(G_2 = (Z_1 \cap G_1) \bigcup (Z_0\cap G_1^c)\)</span>.</p>
<p><span class="citation">Yartseva and Grossglauser (2013)</span> provide an alternative formulation for the correlated model.
First, one samples a single random graph <span class="math inline">\(G\)</span> with edge probability <span class="math inline">\(p&#39;\)</span>.
Conditioned on <span class="math inline">\(G\)</span>, each edge in <span class="math inline">\(G\)</span> is present independently in <span class="math inline">\(G_1,G_2\)</span> with probability <span class="math inline">\(s&#39;\)</span>.
These two parameterizations are related to each other by the relationship <span class="math inline">\(s&#39;=p+\rho(1-p)\)</span> and <span class="math inline">\(p&#39;=p/(p+\rho(1-p))\)</span>.
The original parameterization is slightly more general because it allows for the possibility of negative correlation.</p>
<p>In addition to homogeneous correlated random graphs, we also implement heterogeneous generalizations of this model.
The stochastic block model (<span class="citation">Holland, Laskey, and Leinhardt (1983)</span>) and the random dot product graphs (RDPG) model (<span class="citation">Young and Scheinerman (2007)</span>) can both be regarded as extensions of the model.
The stochastic block model is useful to represent the community structure of graphs by dividing the graph into <span class="math inline">\(K\)</span> groups.
Each node is assigned to a group and the probability of edges is determined by the group memberships of the vertex pair.
For the RDPG model, each vertex is assigned a latent position in <span class="math inline">\(\mathbb{R}^d\)</span> and edge probabilities are given by the inner product between the latent positions of the vertex pair.</p>
<p>For both of these models, we can consider correlated graph-pairs where marginally they arise from one of these models and again corresponding edge pairs are correlated.</p>
</div>
<div id="sec:measure" class="section level2" number="3.4">
<h2><span class="header-section-number">3.4</span> Measures for goodness of matching</h2>
<p>The ability to assess the quality of the match when ground truth is unavailable is critical for the usage of the matching approaches.
There are various topological criteria that can be applied to measure the quality of matching results.
At the graph level, the most frequently used structural measures include matching pairs (MP), edge correctness (EC), and the size of the largest common connected subgraph (LCCS) (<span class="citation">Kuchaiev and Przulj (2011)</span>).
MP counts the number of correctly matched pairs of nodes, thus can only be used when the true alignment is available.
Global counts of common edges (CE) and common non-edges (CNE) can be defined as
<span class="math display">\[\begin{align*}
    CE=\frac{1}{2}\sum_{i,j}1\{A_{ij}=PBP^T_{ij} =1\}\quad CNE=\frac{1}{2}\sum_{i,j}1\{A_{ij}=PBP^T_{ij} = 0\},
\end{align*}\]</span>
along with error counts such extra edges (EE) and missing edges (ME),
<span class="math display">\[\begin{align*}
    EE=\frac{1}{2}\sum_{i,j}1\{A_{ij}=0=1 - PBP^T_{ij}\}\quad ME=\frac{1}{2}\sum_{i,j}1\{A_{ij}= 1 = 1 - PBP^T_{ij}\},
\end{align*}\]</span></p>
<p>EC measures the percentage of correctly aligned edges, that is the fraction CE<span class="math inline">\(/|E_1|\)</span>.
The LCCS denotes the largest subset of aligned vertices such that the corresponding induced subgraphs of each graph are connected.
Matches with a larger LCCS are often preferable to those with many isolated components.</p>
<p>Another group of criteria measures the goodness of matching at the vertex level.
Informally, we aim at testing the hypotheses
<span class="math display">\[H_0^{(v)}: \text{the vertex } v \text{ is not matched correctly by } P^*, \]</span>
<span class="math display">\[H_a^{(v)}: \text{the vertex } v \text{ is matched correctly by } P^*\]</span>
for each vertex <span class="math inline">\(v\)</span>.</p>
<p>The goal is to address if the permutation matrix found by graph matching algorithm is significantly different from the one sampled from uniformly distributed permutation matrices (<span class="citation">Vince Lyzinski and Sussman (2017)</span>).
Unfortunately, vertex-level matching criteria have only received limited attention in the literature, however, we include two test statistics to measure fit.
The row difference statistic is the L<span class="math inline">\(_1\)</span>-norm of the difference between <span class="math inline">\(A\)</span> and <span class="math inline">\(P^*B{P^*}^T\)</span>, namely
<span class="math display">\[\begin{equation*}
T_d(v,P^*):=\Vert A_{v\cdot}-(P^*B{P^*}^T)_{v\cdot}\Vert_1.
\end{equation*}\]</span>
Intuitively, a correctly matched vertex <span class="math inline">\(v\)</span> should induce a smaller <span class="math inline">\(T_d(v,P^*)\)</span>,
which for unweighted graphs corresponds to the number of edge disagreements induced by matching <span class="math inline">\(v\)</span>.
Alternatively, the row correlation statistic is defined as
<span class="math display">\[\begin{equation*}
T_c(v,P^*):=1 - corr(A_{v\cdot},(P^*B{P^*}^T)_{v\cdot}).
\end{equation*}\]</span>
We expect the empirical correlation between the neighborhoods of <span class="math inline">\(v\)</span> in <span class="math inline">\(A\)</span> and <span class="math inline">\(P^*B{P^*}^T\)</span> to be larger for a correctly matched vertex.</p>
<p>We employ permutation testing ideas to the raw statistics as a normalization across vertices.
Let us take the row difference statistic for example.
The guiding intuition is that if <span class="math inline">\(v\)</span> is correctly matched, the number of errors induced by <span class="math inline">\(P^*\)</span> across the neighborhood of <span class="math inline">\(v\)</span> in <span class="math inline">\(A\)</span> and <span class="math inline">\(B\)</span> (i.e., <span class="math inline">\(T_d(v, P^*)\)</span>) should be significantly smaller than the number of errors induced by a randomly chosen permutation <span class="math inline">\(P\)</span> (i.e., <span class="math inline">\(T_d(v, P)\)</span>).</p>
<p>With this in mind, let <span class="math inline">\(\mathbb{E}_P\)</span> and <span class="math inline">\(\mathrm{Var}_P\)</span> denote the conditional expectation and variance of the raw statistic with <span class="math inline">\(P\)</span> uniformly sampled over all permutation matrices.
The normalization is then given by
<span class="math display">\[\begin{equation*}
T_p(v,P^*):=\frac{T(v,P^*)-\mathbb{E}_PT(v,P)}{\sqrt{Var_PT(v,P)}}
\end{equation*}\]</span>
where <span class="math inline">\(T(v, P)\)</span> can be either of the two test statistics we introduced earlier.</p>
<p>In addition to measuring match quality, these vertex-wise statistics can also serve as a tool to find which vertices have no valid match in another network, i.e. the vertex entity is present in one network but not the other.</p>
</div>
</div>
<div id="sec:usage" class="section level1" number="4">
<h1><span class="header-section-number">4</span> R functions and usage</h1>
<p>The R package <code>iGraphMatch</code> offers versatile options for graph matching and subsequent analysis.
Here we describe the usage of the package including sampling random correlated graph pairs, graph matching, and evaluating matching results.</p>
<div id="sampling-correlated-random-graph-pairs" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Sampling correlated random graph pairs</h2>
<p>We first illustrate the usage of functions for sampling correlated random graph pairs.
The usage of graph matching will be demonstrated on the graph-pairs sampled using these methods.</p>
<p>Functions of the form <code>sample_correlated_*_pair</code> for sampling random graph pairs have the common syntax:</p>
<pre><code>sample_correlated_*_pair(n, ***model parameters***, 
  permutation = 1:n, directed = FALSE, loops = FALSE)</code></pre>
<p>The argument <code>n</code> specifies the number of nodes in each graph, and the default options are to sample a pair of undirected graphs without self-loop whose true alignment is the identity.
The <code>permutation</code> argument can be used to permute the vertex labels of the second graph.
The <code>model parameters</code> arguments vary according to different random graph models and typically consist of parameters for marginal graph distributions and for correlations between the corresponding edges.
The functions each return a named list of two <code>igraph</code> objects.</p>
<p>For the homogeneous correlated graph model, the model parameters are <code>p</code>, the global edge probability, and <code>corr</code>, the Pearson correlation between aligned vertex-pairs.
For example, to sample a pair of graphs with 5 nodes from <span class="math inline">\(\mathrm{CorrER}(0.5J, 0.7J)\)</span> we run</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">library</span>(iGraphMatch)</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>cgnp_pair <span class="ot">&lt;-</span> <span class="fu">sample_correlated_gnp_pair</span>(<span class="at">n =</span> <span class="dv">5</span>, <span class="at">corr =</span> <span class="fl">0.7</span>, <span class="at">p =</span> <span class="fl">0.5</span>)</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>(cgnp_g1 <span class="ot">&lt;-</span> cgnp_pair<span class="sc">$</span>graph1)</span></code></pre></div>
<pre><code>## IGRAPH 0095a7a U--- 5 4 -- Erdos-Renyi (gnp) graph
## + attr: name (g/c), type (g/c), loops (g/l), p (g/n)
## + edges from 0095a7a:
## [1] 1--2 2--3 2--5 3--5</code></pre>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>cgnp_g1[]</span></code></pre></div>
<pre><code>## 5 x 5 sparse Matrix of class &quot;dgCMatrix&quot;
##               
## [1,] . 1 . . .
## [2,] 1 . 1 . 1
## [3,] . 1 . . 1
## [4,] . . . . .
## [5,] . 1 1 . .</code></pre>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>cgnp_g2 <span class="ot">&lt;-</span> cgnp_pair<span class="sc">$</span>graph2</span></code></pre></div>
<p>Since we didn’t obscure the vertex correspondence by assigning a value to the <code>permutation</code> argument, the underlying true alignment is the identity.</p>
<p>For the more general heterogeneous correlated graph model, one needs to specify an edge probability matrix and a Pearson correlation matrix.
To sample a pair of graphs from the heterogeneous correlated model again with 5 nodes in each graph, and with random edge probabilities and Pearson correlations:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>p <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">runif</span>(<span class="dv">5</span><span class="sc">^</span><span class="dv">2</span>, .<span class="dv">5</span>, .<span class="dv">8</span>),<span class="dv">5</span>)</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>c <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">runif</span>(<span class="dv">5</span><span class="sc">^</span><span class="dv">2</span>, .<span class="dv">5</span>, .<span class="dv">8</span>),<span class="dv">5</span>)</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>ieg_pair <span class="ot">&lt;-</span> <span class="fu">sample_correlated_ieg_pair</span>(<span class="at">n =</span> <span class="dv">5</span>, <span class="at">p_mat =</span> p, <span class="at">c_mat =</span> c)</span></code></pre></div>
<p>Since the default is undirected graphs without self-loops, the entries of <code>p</code> and <code>c</code> along and below the diagonal are effectively ignored.</p>
<p>The stochastic block model requires block-to-block edge probabilities stored in the <code>pref.matrix</code> argument and the <code>block.sizes</code> argument indicates the size of each block, along with the Pearson correlation parameter <code>corr</code>.
Next, we sample a pair of graphs from the stochastic block model with two blocks of size 2 nodes and 3 nodes respectively, within-group edge probabilities of .7 and .5, across-group edge probability of .001, and Pearson correlation equal to .5.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>pm <span class="ot">&lt;-</span> <span class="fu">cbind</span>(<span class="fu">c</span>(.<span class="dv">7</span>, .<span class="dv">001</span>), <span class="fu">c</span>(.<span class="dv">001</span>, .<span class="dv">5</span>))</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>sbm_pair <span class="ot">&lt;-</span> <span class="fu">sample_correlated_sbm_pair</span>(<span class="at">n =</span> <span class="dv">5</span>, <span class="at">pref.matrix =</span> pm,</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>                                       <span class="at">block.sizes =</span> <span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">3</span>), <span class="at">corr =</span> <span class="fl">0.5</span>)</span></code></pre></div>
<p>The <code>iGraphMatch</code> package also provides functions for sampling a pair of correlated random graphs with junk vertices, i.e vertices that don’t have true correspondence in the other graph by specifying the number of overlapping vertices in the argument <code>ncore</code> or overlapping block sizes in the argument <code>core.block.sizes</code>.</p>
<p>The <code>iGraphMatch</code> package offers auxiliary tools for centering graphs to penalize the incorrect matches as well, which is implemented in the <code>center_graph</code> function with syntax:</p>
<pre><code>center_graph(A, scheme = c(-1, 1), use_splr = TRUE)</code></pre>
<p>with the first input being either a matrix-like or igraph object.
The <code>scheme</code> argument specifies the method for centering graphs.
Options include a pair of scalars where the entries of the adjacency matrix are linearly rescaled so that their minimum is <code>min(scheme)</code> and their maximum is <code>max(scheme)</code>.
Note, <code>scheme = &quot;center&quot;</code> is the same as <code>scheme = c(-1, 1)</code>.
Another option is to pass in a single integer, where the returned value is the adjacency matrix minus its best rank-<code>scheme</code> approximation.
The last argument <code>use_splr</code> is a boolean indicating whether to return a <code>splrMatrix</code> object.
We use <code>use_splr = FALSE</code> here to better display the matrices but <code>use_splr = TRUE</code> will often result in improved performance, especially for large sparse networks.
Here, we center the sampled graph <code>cgnp_g1</code> using different schemes:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="fu">center_graph</span>(cgnp_g1, <span class="at">scheme =</span> <span class="st">&quot;center&quot;</span>, <span class="at">use_splr =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## 5 x 5 Matrix of class &quot;dgeMatrix&quot;
##      [,1] [,2] [,3] [,4] [,5]
## [1,]   -1    1   -1   -1   -1
## [2,]    1   -1    1   -1    1
## [3,]   -1    1   -1   -1    1
## [4,]   -1   -1   -1   -1   -1
## [5,]   -1    1    1   -1   -1</code></pre>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="fu">center_graph</span>(cgnp_g1, <span class="at">scheme =</span> <span class="dv">2</span>, <span class="at">use_splr =</span> <span class="cn">FALSE</span>)</span></code></pre></div>
<pre><code>## 5 x 5 Matrix of class &quot;dgeMatrix&quot;
##        [,1]   [,2]   [,3] [,4]   [,5]
## [1,]  0.207  0.064 -0.093    0 -0.093
## [2,]  0.064  0.020 -0.029    0 -0.029
## [3,] -0.093 -0.029 -0.458    0  0.542
## [4,]  0.000  0.000  0.000    0  0.000
## [5,] -0.093 -0.029  0.542    0 -0.458</code></pre>
<p>Users can then use the centered graphs as inputs to the implemented graph matching algorithms, which serve to alter rewards and penalties for common edges, common non-edges, missing edges, and extra edges.</p>
</div>
<div id="graph-matching-methods" class="section level2" number="4.2">
<h2><span class="header-section-number">4.2</span> Graph matching methods</h2>
<p>The graph matching methods share the same basic syntax:</p>
<pre><code>gm(A, B, seeds = NULL, similarity = NULL, method = &quot;indefinite&quot;, 
  ***algorithm parameters***)</code></pre>
<table>
<caption><span id="tab:gm-alg">Table 4.1: </span> Overview of arguments for different graph matching functions.</caption>
<colgroup>
<col width="17%" />
<col width="21%" />
<col width="39%" />
<col width="21%" />
</colgroup>
<thead>
<tr class="header">
<th>Parameter</th>
<th>Type</th>
<th>Description</th>
<th>Functions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>start</code></td>
<td>Matrix or character</td>
<td>Initialization of the start matrix for iterations.</td>
<td><code>FW, convex</code></td>
</tr>
<tr class="even">
<td><code>lap_method</code></td>
<td>Character</td>
<td>Method for solving linear assignment problem.</td>
<td><code>FW, convex, PATH, IsoRank</code></td>
</tr>
<tr class="odd">
<td><code>max_iter</code></td>
<td>Number</td>
<td>Maximum number of iterations.</td>
<td><code>FW, convex, PATH, IsoRank</code></td>
</tr>
<tr class="even">
<td><code>tol</code></td>
<td>Number</td>
<td>Tolerance of edge disagreements.</td>
<td><code>FW, convex, PATH</code></td>
</tr>
<tr class="odd">
<td><code>r</code></td>
<td>Number</td>
<td>Threshold of neighboring pair scores.</td>
<td><code>percolation</code></td>
</tr>
<tr class="even">
<td><code>ExpandWhenStuck</code></td>
<td>Boolean</td>
<td><code>TRUE</code> if performs <span class="smallcaps">ExpandWhenStuck</span> algorithm.</td>
<td><code>percolation</code></td>
</tr>
</tbody>
</table>
<p>The first two arguments for graph matching algorithms represent two networks which can be matrices, igraph objects, or two lists of either form in the case of multi-layer matching.
The <code>seeds</code> argument contains prior information on the known partial correspondence of two graphs.
It can be a vector of logicals or indices if the seed pairs have the same indices in both graphs.
In general, the <code>seeds</code> argument takes a matrix or a data frame as input with two columns indicating the indices of seeds in the two graphs respectively.
The <code>similarity</code> parameter is for a matrix of similarity scores between the two vertex sets, with larger scores indicating higher similarity.
Notably, one should be careful with the different scales of the graph topological structure and the vertex similarity information in order to properly address the relative importance of each part of the information.
The <code>method</code> argument specifies a graph matching algorithm to use, and one can choose from “indefinite” (default), “convex”, “PATH”, “percolation”, “IsoRank”, “Umeyama”, or a self-defined graph matching function which enables users to test out their own algorithms while remaining compatible with the package.
If <code>method</code> is a function, it should take at least two networks, seeds and similarity scores as arguments.
Users can also include additional arguments if applicable.
The self-defined graph matching function should return an object of the “graphMatch” class with matching correspondence, sizes of two input graphs, and other matching details.
As an illustrative example, <code>graph_match_rand</code> defines a new graph matching function which matches by randomly permuting the vertex label of the second graph using a random seed <code>rand_seed</code>.
We then apply this self-defined GM method to matching the correlated graphs sampled earlier with a specified random seed:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>graph_match_rand <span class="ot">&lt;-</span> <span class="cf">function</span>(A, B, <span class="at">seeds =</span> <span class="cn">NULL</span>, </span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>                             <span class="at">similarity =</span> <span class="cn">NULL</span>, rand_seed){</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>  totv1 <span class="ot">&lt;-</span> <span class="fu">nrow</span>(A[[<span class="dv">1</span>]])</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>  totv2 <span class="ot">&lt;-</span> <span class="fu">nrow</span>(B[[<span class="dv">1</span>]])</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>  nv <span class="ot">&lt;-</span> <span class="fu">max</span>(totv1, totv2)</span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>  <span class="fu">set.seed</span>(rand_seed)</span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a>  corr <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">corr_A =</span> <span class="dv">1</span><span class="sc">:</span>nv, </span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a>                     <span class="at">corr_B =</span> <span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span>nv)[<span class="fu">sample</span>(nv)])</span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a>  <span class="fu">graphMatch</span>(</span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a>    <span class="at">corr =</span> corr,</span>
<span id="cb15-13"><a href="#cb15-13" tabindex="-1"></a>    <span class="at">nnodes =</span> <span class="fu">c</span>(totv1, totv2),</span>
<span id="cb15-14"><a href="#cb15-14" tabindex="-1"></a>    <span class="at">detail =</span> <span class="fu">list</span>(</span>
<span id="cb15-15"><a href="#cb15-15" tabindex="-1"></a>      <span class="at">rand_seed =</span> rand_seed</span>
<span id="cb15-16"><a href="#cb15-16" tabindex="-1"></a>    )</span>
<span id="cb15-17"><a href="#cb15-17" tabindex="-1"></a>  )</span>
<span id="cb15-18"><a href="#cb15-18" tabindex="-1"></a>}</span>
<span id="cb15-19"><a href="#cb15-19" tabindex="-1"></a></span>
<span id="cb15-20"><a href="#cb15-20" tabindex="-1"></a>match_rand <span class="ot">&lt;-</span> <span class="fu">gm</span>(cgnp_g1, cgnp_g2, </span>
<span id="cb15-21"><a href="#cb15-21" tabindex="-1"></a>                 <span class="at">method =</span> graph_match_rand, <span class="at">rand_seed =</span> <span class="dv">123</span>)</span></code></pre></div>
<p>Other arguments vary for different graph matching algorithms with an overview given in Table <span class="math inline">\(\ref{tab:gm-alg}\)</span>.
The <code>start</code> argument for the <span class="smallcaps">FW</span> methodology with “indefinite” and “convex” relaxations takes any <span class="math inline">\(nns\text{-by-}nns\)</span> matrix or an initialization method including “bari”, “rds” or “convex”.
These represent initializing the iterations at a specific matrix, the barycenter, a random doubly stochastic matrix, or the doubly stochastic solution from “convex” method on the same graphs, respectively.</p>
<p>Moreover, sometimes we have access to side information on partial correspondence with uncertainty.
If we still treat such prior information as hard seeds and pass them through the <code>seeds</code> argument for “indefinite” and “convex” methods, incorrect information can yield unsatisfactory matching results.
Instead, we provide the option of soft seeding by incorporating the noisy partial correspondence into the initialization of the start matrix.
The core function used for initializing the start matrix with versatile options is the <code>init_start</code> function.</p>
<p>Suppose the first two pairs of nodes are hard seeds and another pair of incorrect seed <span class="math inline">\((3,4)\)</span> is soft seeds:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>hard_seeds <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span> <span class="sc">&lt;=</span> <span class="dv">2</span></span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>soft_seeds <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">seed_A =</span> <span class="dv">3</span>, <span class="at">seed_B =</span> <span class="dv">4</span>)</span></code></pre></div>
<p>We generate a start matrix incorporating soft seeds initialized at the barycenter:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a><span class="fu">as.matrix</span>(start_bari <span class="ot">&lt;-</span> <span class="fu">init_start</span>(<span class="at">start =</span> <span class="st">&quot;bari&quot;</span>, <span class="at">nns =</span> <span class="dv">3</span>,</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>      <span class="at">ns =</span> <span class="dv">2</span>, <span class="at">soft_seeds =</span> soft_seeds))</span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,]  0.0    1  0.0
## [2,]  0.5    0  0.5
## [3,]  0.5    0  0.5</code></pre>
<p>An alternative is to generate a start matrix that is a random doubly stochastic matrix incorporating soft seeds as follow</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a><span class="fu">as.matrix</span>(start_rds <span class="ot">&lt;-</span> <span class="fu">init_start</span>(<span class="at">start =</span> <span class="st">&quot;rds&quot;</span>, <span class="at">nns =</span> <span class="dv">3</span>,</span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a>      <span class="at">ns =</span> <span class="dv">2</span>, <span class="at">soft_seeds =</span> soft_seeds))</span></code></pre></div>
<pre><code>##      [,1] [,2] [,3]
## [1,] 0.00    1 0.00
## [2,] 0.52    0 0.48
## [3,] 0.48    0 0.52</code></pre>
<p>Then we can initialize the <span class="smallcaps">Frank-Wolfe</span> iterations at any of the start matrix by specifying the <code>start</code> parameter.</p>
<p>When there are no soft seeds, we no longer need to initialize the start matrix by using <code>init_start</code> first. Instead we can directly assign an initialization method to the <code>start</code> argument in the <code>gm</code> function:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a>match_rds <span class="ot">&lt;-</span> <span class="fu">gm</span>(cgnp_g1, cgnp_g2, <span class="at">seeds =</span> hard_seeds,</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>                <span class="at">method =</span> <span class="st">&quot;indefinite&quot;</span>, <span class="at">start =</span> <span class="st">&quot;rds&quot;</span>)</span></code></pre></div>
<p>Below use solution from the convex relaxation as the initialization for the indefinite relaxation.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>match_convex <span class="ot">&lt;-</span> <span class="fu">gm</span>(cgnp_g1, cgnp_g2, <span class="at">seeds =</span> hard_seeds,</span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a>                   <span class="at">method =</span> <span class="st">&quot;indefinite&quot;</span>, <span class="at">start =</span> <span class="st">&quot;convex&quot;</span>)</span></code></pre></div>
<p>Now let’s match the sampled pair of graphs from the stochastic block model by using <span class="smallcaps">Percolation</span> algorithm.
Apart from the common arguments for all the graph matching algorithms, <span class="smallcaps">Percolation</span> has another argument representing the minimum number of matched neighbors required for matching a new qualified vertex pair.
Here we adopt the default value which is 2.
Also, at least one of similarity scores and seeds is required for <span class="smallcaps">Percolation</span> algorithm to kick off.
Let’s utilize the same set of hard seeds and assume there is no available prior information on similarity scores.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>sbm_g1 <span class="ot">&lt;-</span> sbm_pair<span class="sc">$</span>graph1</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>sbm_g2 <span class="ot">&lt;-</span> sbm_pair<span class="sc">$</span>graph2</span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>match_perco <span class="ot">&lt;-</span> <span class="fu">gm</span>(sbm_g1, sbm_g1, <span class="at">seeds =</span> hard_seeds, </span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>                  <span class="at">method =</span> <span class="st">&quot;percolation&quot;</span>, <span class="at">r =</span> <span class="dv">2</span>)</span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a>match_perco</span></code></pre></div>
<pre><code>## gm(A = sbm_g1, B = sbm_g1, seeds = hard_seeds, method = &quot;percolation&quot;, 
##     r = 2)
## 
## Match (5 x 5):
##   corr_A corr_B
## 1      1      1
## 2      2      2</code></pre>
<p>Without enough prior information on partial correspondence, <span class="smallcaps">Percolation</span> couldn’t find any qualifying matches.
Suppose in addition to the current pair of sampled graphs, the above sampled correlated homogeneous and heterogeneous graphs are different layers of connectivity for the same set of vertices.
We can then match the nonseed vertices based on the topological information in all of these three graph layers.
To be consistent, let’s still use the <span class="smallcaps">Percolation</span> algorithm with threshold equal to 2 and the same set of seeds.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>matrix_lA <span class="ot">&lt;-</span> <span class="fu">list</span>(sbm_g1, ieg_pair<span class="sc">$</span>graph1, cgnp_g1)</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>matrix_lB <span class="ot">&lt;-</span> <span class="fu">list</span>(sbm_g2, ieg_pair<span class="sc">$</span>graph2, cgnp_g2)</span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a>match_perco_list <span class="ot">&lt;-</span> <span class="fu">gm</span>(<span class="at">A =</span> matrix_lA, <span class="at">B =</span> matrix_lB, <span class="at">seeds =</span> hard_seeds, </span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a>                       <span class="at">method =</span> <span class="st">&quot;percolation&quot;</span>, <span class="at">r =</span> <span class="dv">2</span>)</span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a>match_perco_list</span></code></pre></div>
<pre><code>## gm(A = matrix_lA, B = matrix_lB, seeds = hard_seeds, method = &quot;percolation&quot;, 
##     r = 2)
## 
## Match (5 x 5):
##   corr_A corr_B
## 1      1      1
## 2      2      2
## 3      3      3
## 4      4      4
## 5      5      5</code></pre>
<p>With the same amount of available prior information, we are now able to match all the nodes correctly.</p>
<p>Finally, we will give an example of matching multi-layers of graphs using <span class="smallcaps">IsoRank</span> algorithm.
Unlike the other algorithm, similarity scores are required for <span class="smallcaps">IsoRank</span> algorithm.
Without further information, we adopt the barycenter as the similarity matrix here.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a>sim <span class="ot">&lt;-</span> <span class="fu">as.matrix</span>(<span class="fu">init_start</span>(<span class="at">start =</span> <span class="st">&quot;bari&quot;</span>, <span class="at">nns =</span> <span class="dv">5</span>, </span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a>                            <span class="at">soft_seeds =</span> hard_seeds))</span>
<span id="cb27-4"><a href="#cb27-4" tabindex="-1"></a>match_IsoRank <span class="ot">&lt;-</span> <span class="fu">gm</span>(<span class="at">A =</span> matrix_lA, <span class="at">B =</span> matrix_lB, </span>
<span id="cb27-5"><a href="#cb27-5" tabindex="-1"></a>                    <span class="at">seeds =</span> hard_seeds, <span class="at">similarity =</span> sim, </span>
<span id="cb27-6"><a href="#cb27-6" tabindex="-1"></a>                    <span class="at">method =</span> <span class="st">&quot;IsoRank&quot;</span>, <span class="at">lap_method =</span> <span class="st">&quot;LAP&quot;</span>)</span></code></pre></div>
<p>Graph matching functions return an object of class “graphMatch” which contains the details of the matching results, including a list of the matching correspondence, a call to the graph matching function and dimensions of the original two graphs.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a>match_convex<span class="sc">@</span>corr</span></code></pre></div>
<pre><code>##   corr_A corr_B
## 1      1      1
## 2      2      2
## 3      3      5
## 4      4      4
## 5      5      3</code></pre>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a>match_convex<span class="sc">@</span>call</span></code></pre></div>
<pre><code>## gm(A = cgnp_g1, B = cgnp_g2, seeds = hard_seeds, method = &quot;indefinite&quot;, 
##     start = &quot;convex&quot;)</code></pre>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a>match_convex<span class="sc">@</span>nnodes</span></code></pre></div>
<pre><code>## [1] 5 5</code></pre>
<p>Additionally, “graphMatch” also returns a list of matching details corresponding to the specified method.
Table <span class="math inline">\(\ref{tab:gm-value}\)</span> provides an overview of returned values for different graph matching methods.
With the <code>seeds</code> information, one can obtain a node mapping for non-seeds accordingly</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a>match_convex[<span class="sc">!</span>match_convex<span class="sc">$</span>seeds]</span></code></pre></div>
<pre><code>##   corr_A corr_B
## 3      3      5
## 4      4      4
## 5      5      3</code></pre>
<table>
<caption><span id="tab:gm-value">Table 4.2: </span> Overview of return values for different graph matching functions.</caption>
<colgroup>
<col width="22%" />
<col width="50%" />
<col width="27%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Parameter</th>
<th align="center">Description</th>
<th align="right">Functions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>seeds</code></td>
<td align="center">A vector of logicals indicating if the corresponding vertex is a seed</td>
<td align="right">All the functions</td>
</tr>
<tr class="even">
<td align="left"><code>soft</code></td>
<td align="center">The functional similarity score matrix with which one can extract more than one matching candidates</td>
<td align="right"><code>FW, convex, PATH, IsoRank, Umeyama</code></td>
</tr>
<tr class="odd">
<td align="left"><code>lap_method</code></td>
<td align="center">Choice for solving the LAP.</td>
<td align="right"><code>FW, convex, Umeyama, IsoRank</code></td>
</tr>
<tr class="even">
<td align="left"><code>iter</code></td>
<td align="center">Number of iterations until convergence or reaches the max_iter.</td>
<td align="right"><code>FW, convex, PATH</code></td>
</tr>
<tr class="odd">
<td align="left"><code>max_iter</code></td>
<td align="center">Maximum number of replacing matches.</td>
<td align="right"><code>FW, convex</code></td>
</tr>
<tr class="even">
<td align="left"><code>match_order</code></td>
<td align="center">The order of vertices getting matched.</td>
<td align="right"><code>percolation, IsoRank</code></td>
</tr>
</tbody>
</table>
<p>The “graphMatch” class object can also be flexibly used as a matrix.
In addition to the returned list of matching correspondence, one can obtain the corresponding permutation matrix in the sparse form.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a>match_convex[]</span></code></pre></div>
<pre><code>## 5 x 5 sparse Matrix of class &quot;dgCMatrix&quot;
##               
## [1,] 1 . . . .
## [2,] . 1 . . .
## [3,] . . . . 1
## [4,] . . . 1 .
## [5,] . . 1 . .</code></pre>
<p>Notably, multiplicity is applicable to the “graphMatch” object directly without converting to the permutation matrix.
This enables obtaining the permuted second graph, that is <span class="math inline">\(PBP^T\)</span> simply by</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a>match_convex <span class="sc">%*%</span> cgnp_g2</span></code></pre></div>
<pre><code>## IGRAPH 8187cd4 UN-- 5 5 -- Erdos-Renyi (gnp) graph
## + attr: name_1 (g/c), name_2 (g/c), type_1 (g/c), type_2 (g/c), loops_1
## | (g/l), loops_2 (g/l), p_1 (g/n), p_2 (g/n), name (g/c), type (g/c),
## | loops (g/l), p (g/n), name (v/n)
## + edges from 8187cd4 (vertex names):
## [1] 5--3 2--5 2--3 1--5 1--2</code></pre>
</div>
<div id="evaluation-of-goodness-of-matching" class="section level2" number="4.3">
<h2><span class="header-section-number">4.3</span> Evaluation of goodness of matching</h2>
<p>Along with the graph matching methodology, <code>iGraphMatch</code> has many capabilities for evaluating and visualizing the matching performance.
After matching two graphs, the function <code>summary</code> can be used to get a summary of the overall matching result in terms of commonly used measures including the number of matches, the number of correct matches, common edges, missing edges, extra edges and the objective function value.
The edge matching information is stored in a data frame named <code>edge_match_info</code>.
Note that <code>summary</code> outputs the number of correct matches only when the true correspondence is known by specifying the <code>true_label</code> argument with a vector indicating the true correspondence in the second graph.
Applying the <code>summary</code> function on the matching result <code>match_convex</code> with <code>true_label = 1:5</code>, indicating the true correspondence is the identity that provides these summaries.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a><span class="fu">summary</span>(match_convex, cgnp_g1, cgnp_g2, <span class="at">true_label =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>)</span></code></pre></div>
<pre><code>## Call: gm(A = cgnp_g1, B = cgnp_g2, seeds = hard_seeds, method = &quot;indefinite&quot;, 
##     start = &quot;convex&quot;)
## 
## # Matches: 3
## # True Matches:  1, # Seeds:  2, # Vertices:  5, 5
##                   
##   common_edges 4.0
##  missing_edges 0.0
##    extra_edges 1.0
##          fnorm 1.4</code></pre>
<p>Applying the <code>summary</code> function to a multi-layer graph matching result returns edge statistics for each layer.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" tabindex="-1"></a><span class="fu">summary</span>(match_IsoRank, matrix_lA, matrix_lB)</span></code></pre></div>
<pre><code>## Call: gm(A = matrix_lA, B = matrix_lB, seeds = hard_seeds, similarity = sim, 
##     method = &quot;IsoRank&quot;, lap_method = &quot;LAP&quot;)
## 
## # Matches: 3, # Seeds:  2, # Vertices:  5, 5
##          layer   1   2   3
##   common_edges 2.0 6.0 4.0
##  missing_edges 0.0 1.0 0.0
##    extra_edges 1.0 0.0 1.0
##          fnorm 1.4 1.4 1.4</code></pre>
<p>In realistic scenarios, the true correspondence is not available.
As introduced in section <span class="math inline">\(\ref{sec:background}\)</span>, the user can use vertex level statistics to evaluate match performance.
The <code>best_matches</code> function evaluates a vertex-level metric and returns a sorted <code>data.frame</code> of the vertex-matches with the metrics.
The arguments are the two networks, a specific measure to use, the number of top-ranked vertex-matches to output, and the matching correspondence in the second graph if applicable.
As an example here, we apply <code>best_matches</code> to rank the matches from above with the true underlying alignment</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" tabindex="-1"></a><span class="fu">best_matches</span>(cgnp_g1, cgnp_g2, <span class="at">match =</span> match_convex, </span>
<span id="cb44-2"><a href="#cb44-2" tabindex="-1"></a>             <span class="at">measure =</span> <span class="st">&quot;row_perm_stat&quot;</span>, <span class="at">num =</span> <span class="dv">3</span>, </span>
<span id="cb44-3"><a href="#cb44-3" tabindex="-1"></a>             <span class="at">true_label =</span> <span class="dv">1</span><span class="sc">:</span>igraph<span class="sc">::</span><span class="fu">vcount</span>(cgnp_g1))</span></code></pre></div>
<pre><code>##   A_best B_best measure_value precision
## 1      4      4          -1.4      1.00
## 2      3      5          -1.2      0.50
## 3      5      3          -1.2      0.33</code></pre>
<p>Note, <code>best_matches</code> uses seed information from the <code>match</code> parameter and only outputs non-seed matches.
Without the true correspondence, <code>true_label</code> would take the default value and the output data frame only contains the first three columns.</p>
<p>To visualize the matches of smaller graphs, the function <code>plot</code> displays edge discrepancies of the two matched graphs by an adjacency matrix or a ball-and-stick plot, depending on the input format of two graphs.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a><span class="fu">plot</span>(cgnp_g1, cgnp_g2, match_convex)</span>
<span id="cb46-2"><a href="#cb46-2" tabindex="-1"></a><span class="fu">plot</span>(cgnp_g1[], cgnp_g2[], match_convex)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:visualization"></span>
<img src="data:image/png;base64,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" alt=" Match visualizations. Grey, blue, and red colors indicate common edges, missing edges present only in the first network, and extra edges present only in the second network, respectively." width="47.5%" /><img src="data:image/png;base64,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f0VmyiRAArlCgAooV54k60ECASRABRTAh8Yik0CuEKACypUnyXqQQAAJUAEF8KGxyCSQKwTSmgXLNIQNGzYIbJNY27SZLg/zJ4GkCDgH/FkHZBakBkUC2wKCHaITTjhB5s+fHxTWLCcJkEAEgUAqIBg6o0fUiCfJUxIIIIFAdsHgGhaeVt36IsJ+Ivgyiibx7kULz2u5RQDvBd6BX2JsicAWGtgzp/hDIHAKCLanZ8+erd4wpk+f7ooKtobAM0c0wf4sjiFFI5Mf19asWSNdu3aNad4XNs7nzJmTHzAyUMtAKaAdO3aocfuXXnopqf9KH374YUy0MK596623xrzPG7lNoH79+vLII4/klGPCID2xQI0BDR48WDeNwiUzBp/RdIa1fviqppAACfhDAE4IE5ktgRNSWEe1H/w23UigFBBMM0DhwNQHPvARDzMar732mpu6MgwJkEASBOD4E76/OnfurMtd3njjjZixYU0CQxn207hx45hhw28EqguGrle4wOkhHBMCEIUESMA7AmjBwFEhXK3D3hd+exdffLH2NqztL5sbWj9oGKxfv1599eF6sWLF7O2434FqAcWtCW+SQMAIFDOeUUuabovXnxIuuz/xcGHSBhY2rcvlnj17qnJ56623ikSDyy2Y5qlZs6b6CStdunTIQGGRwBEXAtUCiii7rF27NvISz0kg7wnsM2Zm4bocSiNS0FUaPnx45OUi52jNQKGES40aNaKOt8IVO4wNtm3bVhYuXCgY2J88ebI0adIkPHrU40AroKg14kUSyHMCxY0ygKVH+OaLFLc2yeH6vGLFioWiV6hQIeraO8e05Fq3bi0PPPCAhr/pppukW7dugiUOidZQUQEVQswTEgg+ASgg/PB79OjhujKnnHKK/Pjjjxr+qquuUnfrO3fuLBQf53DDHikYK8LHym233aYtIDgthW3veEIFFI8O75FAnhDAWig71Y6u1tdff62DyuHVx3R8NHdbM2fOlMqVK0u7du00OAagsYIc6SQSKqBEhHifBPKAALpQ4QLlUaJECXn88ccFnkOeeeYZVVDWecO8efOkevXqOk6EltGNN96o4z9oef3jH/+Q9u3bC1wrJRLOgiUixPskkIcE0IKZNGmSYN9l1apVZcyYMfLUU08JZrggAwcOFLsV6qKLLlLvOA2NeysoJewuePTRR11RYwvIFab0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" alt=" Match visualizations. Grey, blue, and red colors indicate common edges, missing edges present only in the first network, and extra edges present only in the second network, respectively." width="47.5%" />
<p class="caption">
Figure 4.1:  Match visualizations. Grey, blue, and red colors indicate common edges, missing edges present only in the first network, and extra edges present only in the second network, respectively.
</p>
</div>
<p>The plots for visualizing matching performance of <code>match_convex</code> are shown in Figure <a href="#fig:visualization">4.1</a>.
Grey edges and pixels indicate common edges, red ones indicate edges only in the second graph.
If they were present, blue pixels and edges represent missing edges that only exist in the first graph.
The corresponding linetypes are solid, short dash, and long dash.</p>
</div>
</div>
<div id="sec:example" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Examples</h1>
<p>In this section, we demonstrate graph matching analysis using <code>iGraphMatch</code> via examples on real datasets, including communication networks, neuronal networks, and transportation networks.
Table <a href="#tab:dataset-overview">5.1</a> presents brief overviews of the first two datasets.
Note that the number of edges doesn’t consider weights for weighted graphs, and for directed graphs, an edge from node <span class="math inline">\(i\)</span> to node <span class="math inline">\(j\)</span> and another edge from <span class="math inline">\(j\)</span> to <span class="math inline">\(i\)</span> will be counted as two edges.
Tables <a href="#tab:edge-summary">5.2</a> and <a href="#tab:edge-summary-trans">5.3</a> summarize the edge correspondence between two graphs under the true alignment including the number of common edges, missing edges, and extra edges in two graphs.</p>
<p>In the first Enron email network example, we demonstrate the usage of <span class="smallcaps">Frank-Wolfe</span> methodology and how to improve matching performance by using the centering technique and incorporating adaptive seeds.
In the second example using <em>C. Elegans</em> synapses networks, we illustrate how to use soft matching for a challenging graph matching task using <span class="smallcaps">Frank-Wolfe</span> methodology, <span class="smallcaps">PATH</span> algorithm and <span class="smallcaps">IsoRank</span> algorithm.
Finally, we include an example of matching two multi-layer graphs with similarity scores on the Britain transportation networks.</p>
<table>
<caption><span id="tab:dataset-overview">Table 5.1: </span>Overview of the Enron and C. Elegans graphs.</caption>
<colgroup>
<col width="15%" />
<col width="12%" />
<col width="16%" />
<col width="16%" />
<col width="12%" />
<col width="12%" />
<col width="13%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Dataset</th>
<th align="left"># Nodes</th>
<th align="left"># Edges</th>
<th align="right">Correlation</th>
<th align="left">Weighted</th>
<th align="left">Directed</th>
<th align="left">Loop</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Enron</td>
<td align="left">184</td>
<td align="left">488 / 482</td>
<td align="right">0.85</td>
<td align="left">No</td>
<td align="left">Yes</td>
<td align="left">Yes / Yes</td>
</tr>
<tr class="even">
<td align="left">C. Elegans</td>
<td align="left">279</td>
<td align="left">2194 / 1031</td>
<td align="right">0.10</td>
<td align="left">Yes</td>
<td align="left">Yes</td>
<td align="left">No / Yes</td>
</tr>
</tbody>
</table>
<table>
<caption><span id="tab:edge-summary">Table 5.2: </span>Edge summary under the true alignments of the Enron and C. Elegans graphs. The columns indicate the number of common edges, missing edges in <span class="math inline">\(G_1\)</span>, and extra edges in <span class="math inline">\(G_2\)</span>. For weighted graphs, we define a pair of corresponding edges as a common edge as long as they both have positive weights.</caption>
<thead>
<tr class="header">
<th align="left">Dataset</th>
<th align="right">Common edges</th>
<th align="right">Missing edges</th>
<th align="right">Extra edges</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Enron</td>
<td align="right">412</td>
<td align="right">76</td>
<td align="right">70</td>
</tr>
<tr class="even">
<td align="left">C. Elegans</td>
<td align="right">116</td>
<td align="right">981</td>
<td align="right">400</td>
</tr>
</tbody>
</table>
<div id="sec:Enron" class="section level2" number="5.1">
<h2><span class="header-section-number">5.1</span> Example: Enron Email Network Data</h2>
<p>The Enron email network data was originally made public by the Federal Energy Commission during the investigation into the Enron Corporation (<span class="citation">Leskovec et al. (2008)</span>).
<!-- DLS: Citation -->
Each node of Enron network represents an email address and if there is at least one email sent from one address to another address, a directed edge exists between the corresponding nodes.</p>
<p>The <code>iGraphMatch</code> package includes the Enron email network data in the form of a pair of <code>igraph</code> objects derived from the original data where each graph represents one week of emails between 184 email addresses.
The two networks are unweighted and directed with edge densities around
0.01 in each graph and the empirical correlation between two graphs is 0.85.</p>
<p>First, let’s load packages required for the following analysis:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb47-1"><a href="#cb47-1" tabindex="-1"></a><span class="fu">library</span>(igraph)</span>
<span id="cb47-2"><a href="#cb47-2" tabindex="-1"></a><span class="fu">library</span>(iGraphMatch)</span>
<span id="cb47-3"><a href="#cb47-3" tabindex="-1"></a><span class="fu">library</span>(purrr)</span>
<span id="cb47-4"><a href="#cb47-4" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span></code></pre></div>
<div id="visualization-of-enron-networks" class="section level3" number="5.1.1">
<h3><span class="header-section-number">5.1.1</span> Visualization of Enron networks</h3>
<p>We visualize the aligned Enron networks using the function with vertices sorted by a community detection algorithm (<span class="citation">Clauset, Newman, and Moore (2004)</span>) and degree.
For detailed interpretations to figure <a href="#fig:Enron-graph">5.1</a>, please refer to figure <a href="#fig:visualization">4.1</a>.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a>g <span class="ot">&lt;-</span> igraph<span class="sc">::</span><span class="fu">as.undirected</span>(Enron[[<span class="dv">1</span>]])</span>
<span id="cb48-2"><a href="#cb48-2" tabindex="-1"></a>com <span class="ot">&lt;-</span> igraph<span class="sc">::</span><span class="fu">membership</span>(igraph<span class="sc">::</span><span class="fu">cluster_fast_greedy</span>(g))</span>
<span id="cb48-3"><a href="#cb48-3" tabindex="-1"></a>deg <span class="ot">&lt;-</span> <span class="fu">rowSums</span>(<span class="fu">as.matrix</span>(g[]))</span>
<span id="cb48-4"><a href="#cb48-4" tabindex="-1"></a>ord <span class="ot">&lt;-</span> <span class="fu">order</span>(<span class="fu">max</span>(deg)<span class="sc">*</span>com<span class="sc">+</span>deg)</span>
<span id="cb48-5"><a href="#cb48-5" tabindex="-1"></a><span class="fu">plot</span>(Enron[[<span class="dv">1</span>]][][ord,ord], Enron[[<span class="dv">2</span>]][][ord,ord])</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:Enron-graph"></span>
<img src="data:image/png;base64,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" alt="Asymmetric adjacency matrices of aligned Enron Corporation communication networks. The vertices are sorted by a community detection algorithm (@community_detection) and degree." />
<p class="caption">
Figure 5.1: Asymmetric adjacency matrices of aligned Enron Corporation communication networks. The vertices are sorted by a community detection algorithm (<span class="citation">Clauset, Newman, and Moore (2004)</span>) and degree.
</p>
</div>
<p>Note that 37 and 32 out of the total 184 nodes are isolated from the other nodes in two graphs respectively, indicating the corresponding employees haven’t sent or received emails from other employees.
This adds difficulty to matching since it’s impossible to distinguish the isolated nodes based on topological structure alone.
We first keep only the largest connected component of each graph.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" tabindex="-1"></a>vid1 <span class="ot">&lt;-</span> <span class="fu">which</span>(<span class="fu">largest_cc</span>(Enron[[<span class="dv">1</span>]])<span class="sc">$</span>keep)</span>
<span id="cb49-2"><a href="#cb49-2" tabindex="-1"></a>vid2 <span class="ot">&lt;-</span> <span class="fu">which</span>(<span class="fu">largest_cc</span>(Enron[[<span class="dv">2</span>]])<span class="sc">$</span>keep)</span>
<span id="cb49-3"><a href="#cb49-3" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" tabindex="-1"></a>vinsct <span class="ot">&lt;-</span> <span class="fu">intersect</span>(vid1, vid2) </span>
<span id="cb49-5"><a href="#cb49-5" tabindex="-1"></a>v1 <span class="ot">&lt;-</span> <span class="fu">setdiff</span>(vid1, vid2)</span>
<span id="cb49-6"><a href="#cb49-6" tabindex="-1"></a>v2 <span class="ot">&lt;-</span> <span class="fu">setdiff</span>(vid2, vid1)</span>
<span id="cb49-7"><a href="#cb49-7" tabindex="-1"></a>A <span class="ot">&lt;-</span> Enron[[<span class="dv">1</span>]][][<span class="fu">c</span>(vinsct, v1), <span class="fu">c</span>(vinsct, v1)]</span>
<span id="cb49-8"><a href="#cb49-8" tabindex="-1"></a>B <span class="ot">&lt;-</span> Enron[[<span class="dv">2</span>]][][<span class="fu">c</span>(vinsct, v2), <span class="fu">c</span>(vinsct, v2)]</span></code></pre></div>
<p>The sizes of largest connect components of two graphs are 146 and 151, which are different.
We reorder two graphs so that the first 145 nodes are aligned and common to both graphs.</p>
</div>
<div id="matching-largest-connected-components-using-fw-algorithm" class="section level3" number="5.1.2">
<h3><span class="header-section-number">5.1.2</span> Matching largest connected components using FW Algorithm</h3>
<p>Let’s assume the Enron email communication network from the second week is anonymous, and we aim at
finding an alignment between the email addresses from the first network and the second one to de-anonymize the latter.
Additionally, we want to find the email addresses that are active in both months.</p>
<p>Suppose no prior information on partial alignment is available in this example.
We match the two largest connected components using the <span class="smallcaps">FW</span> algorithm with indefinite relaxation since seeds and similarity scores are not mandatory for this method.</p>
<p>Without any prior information, and arguments take default values which are .
For the argument, we assign equal likelihood to all the possible matches by initializing at the barycenter.
Since two graphs are of different sizes, the function automatically pads the smaller graph with extra 0’s.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb50-2"><a href="#cb50-2" tabindex="-1"></a>match_FW <span class="ot">&lt;-</span> <span class="fu">gm</span>(<span class="at">A =</span> A, <span class="at">B =</span> B, <span class="at">start =</span> <span class="st">&quot;bari&quot;</span>, <span class="at">max_iter =</span> <span class="dv">200</span>)</span>
<span id="cb50-3"><a href="#cb50-3" tabindex="-1"></a><span class="fu">head</span>(match_FW)</span></code></pre></div>
<pre><code>##   corr_A corr_B
## 1      1     27
## 2      2      2
## 3      3     30
## 4      4      4
## 5      5      5
## 6      6      6</code></pre>
<p>Then, we check the summary of matching performance in terms of matched nodes, matched edges and the graph matching objective function.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" tabindex="-1"></a><span class="fu">summary</span>(match_FW, A, B)</span></code></pre></div>
<pre><code>## Call: gm(A = A, B = B, start = &quot;bari&quot;, max_iter = 200)
## 
## # Matches: 151, # Seeds:  0, # Vertices:  146, 151
##                   
##   common_edges 353
##  missing_edges 134
##    extra_edges 128
##          fnorm  16</code></pre>
<p>In this example, we can evaluate the matching result based on statistics on matched edges.
Without any seeds or similarity scores, around 72% of edges are correctly matched.</p>
</div>
<div id="centering-the-larger-graph" class="section level3" number="5.1.3">
<h3><span class="header-section-number">5.1.3</span> Centering the larger graph</h3>
<p>We can try to improve performance by centering <code>B</code> by assigning -1 to non-edges, so that we penalize edges that are missing in <code>B</code> but present in <code>A</code>.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" tabindex="-1"></a>A_center <span class="ot">&lt;-</span> <span class="fu">center_graph</span>(<span class="at">A =</span> A, <span class="at">scheme =</span> <span class="st">&quot;naive&quot;</span>, <span class="at">use_splr =</span> <span class="cn">TRUE</span>)</span>
<span id="cb54-2"><a href="#cb54-2" tabindex="-1"></a>B_center <span class="ot">&lt;-</span> <span class="fu">center_graph</span>(<span class="at">A =</span> B, <span class="at">scheme =</span> <span class="st">&quot;center&quot;</span>, <span class="at">use_splr =</span> <span class="cn">TRUE</span>)</span>
<span id="cb54-3"><a href="#cb54-3" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb54-4"><a href="#cb54-4" tabindex="-1"></a>match_FW_center <span class="ot">&lt;-</span> <span class="fu">gm</span>(<span class="at">A =</span> A_center, <span class="at">B =</span> B_center, </span>
<span id="cb54-5"><a href="#cb54-5" tabindex="-1"></a>                           <span class="at">start =</span> <span class="st">&quot;bari&quot;</span>, <span class="at">max_iter =</span> <span class="dv">200</span>)</span>
<span id="cb54-6"><a href="#cb54-6" tabindex="-1"></a><span class="fu">summary</span>(match_FW_center, A, B)</span></code></pre></div>
<pre><code>## Call: gm(A = A_center, B = B_center, start = &quot;bari&quot;, max_iter = 200)
## 
## # Matches: 151, # Seeds:  0, # Vertices:  146, 151
##                   
##   common_edges 396
##  missing_edges  91
##    extra_edges  85
##          fnorm  13</code></pre>
<p>From the summary tables, we would prefer matching Enron networks with the application of the centering scheme, since we get more matched common edges, as well as fewer missing edges and extra edges.</p>
</div>
<div id="matching-with-adaptive-seeds" class="section level3" number="5.1.4">
<h3><span class="header-section-number">5.1.4</span> Matching with adaptive seeds</h3>
<p>Supposing we have no access to ground truth, we use the function to measure and rank the vertex-wise matching performance.
Below shows the 6 matches that minimize the row permutation statistic.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" tabindex="-1"></a>bm <span class="ot">&lt;-</span> <span class="fu">best_matches</span>(<span class="at">A =</span> A, <span class="at">B =</span> B, <span class="at">match =</span> match_FW_center, </span>
<span id="cb56-2"><a href="#cb56-2" tabindex="-1"></a>             <span class="at">measure =</span> <span class="st">&quot;row_perm_stat&quot;</span>)</span>
<span id="cb56-3"><a href="#cb56-3" tabindex="-1"></a><span class="fu">head</span>(bm)</span></code></pre></div>
<pre><code>##      A_best B_best measure_value
## V83      65     65         -40.6
## V75      57     57          -3.4
## V147    115    115          -3.2
## V59      43     43          -2.9
## V64      48     48          -2.3
## V51      36     36          -1.9</code></pre>
<p>Since seeded graph matching enhances the graph matching performance substantially (<span class="citation">Vince Lyzinski, Fishkind, and Priebe (2014)</span>), it may be useful to use some of these best matches as seeds to improve matching results.
Here, we use adaptive seeds, taking the <span class="math inline">\(ns\)</span> best matches and using them as seeds in a second run of the matching algorithm.
The table below displays edge statistics and objective function values for different number of adaptive seeds used.
The second column in the table shows the matching precision of the adaptive seeds based on ground truth.
Incorporating adaptive seeds and repeating the <span class="smallcaps">FW</span> matching procedure on centered graphs further improve the matching results, compared with the case without any adaptive seeds when <span class="math inline">\(ns=0\)</span>.
The first 40 pairs of matched nodes ranked by function are all correctly matched, and this is also when matching is improved the most.</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb58-1"><a href="#cb58-1" tabindex="-1"></a>match_w_hard_seeds <span class="ot">&lt;-</span> <span class="cf">function</span>(ns){</span>
<span id="cb58-2"><a href="#cb58-2" tabindex="-1"></a>  seeds_bm <span class="ot">&lt;-</span> <span class="fu">head</span>(bm, ns)</span>
<span id="cb58-3"><a href="#cb58-3" tabindex="-1"></a>  precision <span class="ot">&lt;-</span> <span class="fu">mean</span>(seeds_bm<span class="sc">$</span>A_best <span class="sc">==</span> seeds_bm<span class="sc">$</span>B_best)</span>
<span id="cb58-4"><a href="#cb58-4" tabindex="-1"></a>  match_FW_center_seeds <span class="ot">&lt;-</span> <span class="fu">gm</span>(<span class="at">A =</span> A_center, <span class="at">B =</span> B_center,</span>
<span id="cb58-5"><a href="#cb58-5" tabindex="-1"></a>                           <span class="at">seeds =</span> seeds_bm, <span class="at">similarity =</span> <span class="cn">NULL</span>,</span>
<span id="cb58-6"><a href="#cb58-6" tabindex="-1"></a>                           <span class="at">start =</span> <span class="st">&quot;bari&quot;</span>, <span class="at">max_iter =</span> <span class="dv">100</span>)</span>
<span id="cb58-7"><a href="#cb58-7" tabindex="-1"></a>  edge_info <span class="ot">&lt;-</span> <span class="fu">summary</span>(match_FW_center_seeds, A, B)<span class="sc">$</span>edge_match_info</span>
<span id="cb58-8"><a href="#cb58-8" tabindex="-1"></a>  <span class="fu">cbind</span>(ns, precision, edge_info)</span>
<span id="cb58-9"><a href="#cb58-9" tabindex="-1"></a>}</span>
<span id="cb58-10"><a href="#cb58-10" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">12345</span>)</span>
<span id="cb58-11"><a href="#cb58-11" tabindex="-1"></a><span class="fu">map_dfr</span>(<span class="fu">seq</span>(<span class="at">from =</span> <span class="dv">0</span>, <span class="at">to =</span> <span class="dv">80</span>, <span class="at">by =</span> <span class="dv">20</span>), match_w_hard_seeds)</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">ns</th>
<th align="right">precision</th>
<th align="right">common</th>
<th align="right">missing</th>
<th align="right">extra</th>
<th align="right">fnorm</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">0</td>
<td align="right">NaN</td>
<td align="right">327</td>
<td align="right">160</td>
<td align="right">154</td>
<td align="right">18</td>
</tr>
<tr class="even">
<td align="right">20</td>
<td align="right">1.00</td>
<td align="right">411</td>
<td align="right">76</td>
<td align="right">70</td>
<td align="right">12</td>
</tr>
<tr class="odd">
<td align="right">40</td>
<td align="right">0.98</td>
<td align="right">407</td>
<td align="right">80</td>
<td align="right">74</td>
<td align="right">12</td>
</tr>
<tr class="even">
<td align="right">60</td>
<td align="right">0.90</td>
<td align="right">393</td>
<td align="right">94</td>
<td align="right">88</td>
<td align="right">13</td>
</tr>
<tr class="odd">
<td align="right">80</td>
<td align="right">0.86</td>
<td align="right">397</td>
<td align="right">90</td>
<td align="right">84</td>
<td align="right">13</td>
</tr>
</tbody>
</table>
<p>As the number of adaptive seeds increases, the precision of adaptive seeds decreases.
Note that if they are treated as hard seeds, incorrect matches will remain in the matched set and might cause a cascade of errors.
An alternative way is to treat the top-ranked matches as soft seeds embedded in the start matrix to handle the uncertainty.
In this way, adaptive seeds not only provide prior information but also evolve over iterations.
The table below shows that the soft seeding approach always outperforms or performs as good as the hard seeding approach regardless of the number of adaptive seeds being used.</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" tabindex="-1"></a>match_w_soft_seeds <span class="ot">&lt;-</span> <span class="cf">function</span>(ns){</span>
<span id="cb59-2"><a href="#cb59-2" tabindex="-1"></a>  seeds_bm <span class="ot">&lt;-</span> <span class="fu">head</span>(bm, ns)</span>
<span id="cb59-3"><a href="#cb59-3" tabindex="-1"></a>  precision <span class="ot">&lt;-</span> <span class="fu">mean</span>(seeds_bm<span class="sc">$</span>A_best <span class="sc">==</span> seeds_bm<span class="sc">$</span>B_best)</span>
<span id="cb59-4"><a href="#cb59-4" tabindex="-1"></a>  start_soft <span class="ot">&lt;-</span> <span class="fu">init_start</span>(<span class="at">start =</span> <span class="st">&quot;bari&quot;</span>, </span>
<span id="cb59-5"><a href="#cb59-5" tabindex="-1"></a>                           <span class="at">nns =</span> <span class="fu">max</span>(<span class="fu">dim</span>(A)[<span class="dv">1</span>], <span class="fu">dim</span>(B)[<span class="dv">1</span>]), </span>
<span id="cb59-6"><a href="#cb59-6" tabindex="-1"></a>                           <span class="at">soft_seeds =</span> seeds_bm)</span>
<span id="cb59-7"><a href="#cb59-7" tabindex="-1"></a>  match_FW_center_soft_seeds <span class="ot">&lt;-</span> <span class="fu">gm</span>(<span class="at">A =</span> A_center, <span class="at">B =</span> B_center, </span>
<span id="cb59-8"><a href="#cb59-8" tabindex="-1"></a>                           <span class="at">start =</span> start_soft, <span class="at">max_iter =</span> <span class="dv">100</span>)</span>
<span id="cb59-9"><a href="#cb59-9" tabindex="-1"></a>  edge_info <span class="ot">&lt;-</span> <span class="fu">summary</span>(match_FW_center_soft_seeds, A, B)<span class="sc">$</span>edge_match_info</span>
<span id="cb59-10"><a href="#cb59-10" tabindex="-1"></a>  <span class="fu">cbind</span>(ns, precision, edge_info)</span>
<span id="cb59-11"><a href="#cb59-11" tabindex="-1"></a>}</span>
<span id="cb59-12"><a href="#cb59-12" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">12345</span>)</span>
<span id="cb59-13"><a href="#cb59-13" tabindex="-1"></a><span class="fu">map_dfr</span>(<span class="fu">seq</span>(<span class="at">from =</span> <span class="dv">0</span>, <span class="at">to =</span> <span class="dv">80</span>, <span class="at">by =</span> <span class="dv">20</span>), match_w_soft_seeds)</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">ns</th>
<th align="right">precision</th>
<th align="right">common</th>
<th align="right">missing</th>
<th align="right">extra</th>
<th align="right">fnorm</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">0</td>
<td align="right">NaN</td>
<td align="right">327</td>
<td align="right">160</td>
<td align="right">154</td>
<td align="right">18</td>
</tr>
<tr class="even">
<td align="right">20</td>
<td align="right">1.00</td>
<td align="right">410</td>
<td align="right">77</td>
<td align="right">71</td>
<td align="right">12</td>
</tr>
<tr class="odd">
<td align="right">40</td>
<td align="right">0.98</td>
<td align="right">407</td>
<td align="right">80</td>
<td align="right">74</td>
<td align="right">12</td>
</tr>
<tr class="even">
<td align="right">60</td>
<td align="right">0.90</td>
<td align="right">398</td>
<td align="right">89</td>
<td align="right">83</td>
<td align="right">13</td>
</tr>
<tr class="odd">
<td align="right">80</td>
<td align="right">0.86</td>
<td align="right">398</td>
<td align="right">89</td>
<td align="right">83</td>
<td align="right">13</td>
</tr>
</tbody>
</table>
</div>
<div id="core-vertices-detection" class="section level3" number="5.1.5">
<h3><span class="header-section-number">5.1.5</span> Core vertices detection</h3>
<p>The function can also be used to detect core vertices.
Suppose the ground truth is known and that the first 145 vertices are core vertices.
The mean precision of detecting core vertices and junk vertices using function is displayed in figure <span class="math inline">\(\ref{fig:core}\)</span>.
A lower rank is a stronger indicator of a core vertex and a higher rank is a stronger indicator of a junk vertex.
Let <span class="math inline">\(r^C_i, 1\le i\le n_c\)</span> and <span class="math inline">\(r^J_j, 1\le j\le n_j\)</span> denote the ranks associated with each core vertex and each junk vertex.
The figure shows the precision of identifying core vertices at each low rank <span class="math inline">\(r\)</span>, i.e. <span class="math inline">\(\frac{1}{r}\sum_{i = 1}^{n_c}1_{r^C_i\le r}\)</span>,
and the precision of identifying junk vertices at each high rank <span class="math inline">\(r\)</span>, i.e. <span class="math inline">\(\frac{1}{r}\sum_{j = 1}^{n_j}1_{r^J_j\ge n_c+n_j-r}\)</span>, which are separated by the vertical lines.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" tabindex="-1"></a>nc <span class="ot">&lt;-</span> <span class="fu">length</span>(vinsct)</span>
<span id="cb60-2"><a href="#cb60-2" tabindex="-1"></a>nj <span class="ot">&lt;-</span> <span class="fu">max</span>(<span class="fu">length</span>(v1), <span class="fu">length</span>(v2))</span>
<span id="cb60-3"><a href="#cb60-3" tabindex="-1"></a>core_precision <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span>nc <span class="sc">%&gt;%</span> <span class="fu">map_dbl</span>(<span class="sc">~</span><span class="fu">mean</span>(bm<span class="sc">$</span>A_best[<span class="dv">1</span><span class="sc">:</span>.x]<span class="sc">&lt;=</span>nc))</span>
<span id="cb60-4"><a href="#cb60-4" tabindex="-1"></a>junk_precision <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span>nj <span class="sc">%&gt;%</span> <span class="fu">map_dbl</span>(<span class="sc">~</span><span class="fu">mean</span>(bm<span class="sc">$</span>A_best[(nc<span class="sc">+</span>.x)<span class="sc">:</span>(nc<span class="sc">+</span>nj)]<span class="sc">&gt;</span>nc))</span></code></pre></div>
<p>Core detection performance is substantially better than chance, as represented by the dotted horizontal lines.
The top 88 are all core vertices indicating good overall performance for core identification.
For junk identification, the junk vertices are ranked 63, 62, 61, 49, 15, 10 according to which have the lowest score, indicating that some junk vertices are difficult to identify.</p>
<div class="figure"><span style="display:block;" id="fig:unnamed-chunk-1"></span>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAYAAAAUg66AAAAEDmlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPpu5syskzoPUpqaSDv41lLRsUtGE2uj+ZbNt3CyTbLRBkMns3Z1pJjPj/KRpKT4UQRDBqOCT4P9bwSchaqvtiy2itFCiBIMo+ND6R6HSFwnruTOzu5O4a73L3PnmnO9+595z7t4LkLgsW5beJQIsGq4t5dPis8fmxMQ6dMF90A190C0rjpUqlSYBG+PCv9rt7yDG3tf2t/f/Z+uuUEcBiN2F2Kw4yiLiZQD+FcWyXYAEQfvICddi+AnEO2ycIOISw7UAVxieD/Cyz5mRMohfRSwoqoz+xNuIB+cj9loEB3Pw2448NaitKSLLRck2q5pOI9O9g/t/tkXda8Tbg0+PszB9FN8DuPaXKnKW4YcQn1Xk3HSIry5ps8UQ/2W5aQnxIwBdu7yFcgrxPsRjVXu8HOh0qao30cArp9SZZxDfg3h1wTzKxu5E/LUxX5wKdX5SnAzmDx4A4OIqLbB69yMesE1pKojLjVdoNsfyiPi45hZmAn3uLWdpOtfQOaVmikEs7ovj8hFWpz7EV6mel0L9Xy23FMYlPYZenAx0yDB1/PX6dledmQjikjkXCxqMJS9WtfFCyH9XtSekEF+2dH+P4tzITduTygGfv58a5VCTH5PtXD7EFZiNyUDBhHnsFTBgE0SQIA9pfFtgo6cKGuhooeilaKH41eDs38Ip+f4At1Rq/sjr6NEwQqb/I/DQqsLvaFUjvAx+eWirddAJZnAj1DFJL0mSg/gcIpPkMBkhoyCSJ8lTZIxk0TpKDjXHliJzZPO50dR5ASNSnzeLvIvod0HG/mdkmOC0z8VKnzcQ2M/Yz2vKldduXjp9bleLu0ZWn7vWc+l0JGcaai10yNrUnXLP/8Jf59ewX+c3Wgz+B34Df+vbVrc16zTMVgp9um9bxEfzPU5kPqUtVWxhs6OiWTVW+gIfywB9uXi7CGcGW/zk98k/kmvJ95IfJn/j3uQ+4c5zn3Kfcd+AyF3gLnJfcl9xH3OfR2rUee80a+6vo7EK5mmXUdyfQlrYLTwoZIU9wsPCZEtP6BWGhAlhL3p2N6sTjRdduwbHsG9kq32sgBepc+xurLPW4T9URpYGJ3ym4+8zA05u44QjST8ZIoVtu3qE7fWmdn5LPdqvgcZz8Ww8BWJ8X3w0PhQ/wnCDGd+LvlHs8dRy6bLLDuKMaZ20tZrqisPJ5ONiCq8yKhYM5cCgKOu66Lsc0aYOtZdo5QCwezI4wm9J/v0X23mlZXOfBjj8Jzv3WrY5D+CsA9D7aMs2gGfjve8ArD6mePZSeCfEYt8CONWDw8FXTxrPqx/r9Vt4biXeANh8vV7/+/16ffMD1N8AuKD/A/8leAvFY9bLAAAAOGVYSWZNTQAqAAAACAABh2kABAAAAAEAAAAaAAAAAAACoAIABAAAAAEAAAEgoAMABAAAAAEAAAEgAAAAAKtAJY0AAChwSURBVHgB7Z0JlBTFGcc/7uVe5D6UawFhUURIEJbjgQS51ggvKOEBLiIPkBjERBI1GszjkcjDQEJikAQB5YhPBHQ5BFxZASFyQ+QIcoNyLofAcghs5l+mOj2zM7u9zEztdM+/3pvt7urq6qpfd3/71VdVXxXJ8QVhIAESIIFCIFC0EO7JW5IACZCAIkABxBeBBEig0AhQABUaet6YBEiAAojvAAmQQKERoAAqNPS8MQmQAAUQ3wESIIFCI+ApAXT27Fl55ZVXCg0mb0wCXiDw7bffSlZWlpGqeEoAXb16VdavX28EHG9CAl4lcP78eTl9+rSR6nlKABkhxpuQAAlEjEDxiOXEjEiABDxBoHbt2nL79m0jdaEAMoKZNyEB9xAoXtycWGATzD3vBUtKAp4jQAHkuUfKCpGAewgYF0BXrlzJk87Nmzfl+vXrudKgh8tUuzTXzRlBAiQQFQJGGns3btyQNWvWqF+5cuVk7NixQSuzaNEiKV++vOzatUvKlCkjw4YNU8Jo7ty5UqdOHcnIyJD+/ftLy5Ytg17PSBIggfAJXLx4Ub777jupUqVK+Jnlk4MRDQjjCurWrStNmjSRkiVLBi3SwYMHZf/+/dK1a1cZPXq0rFq1So4cOSLz58+XZs2aSbdu3WTIkCEyefLkoNczkgRIIDIELly4IGfOnIlMZvnkYkQDql69uuC3ceNGKVGiRNAibdiwQZKSkqxzycnJcuDAAVm3bp306dNHxTdu3Fi++eYbuXXrlhQrVsxKG87O3r17VX7IA77ZihQpon7Y18f2c/pe+hzSuymtvfxFixb1KzvqgoCmrt7HMernxrTQtu+55x5UgSFGCRgRQPa6hxIc586d81P5KlSoIJDEiEdzDAEfAfYxVLxSpUr2bO94H5IedicE+4eGDxAfYuCHp2/kxrSBQkUfoy56P5CDPtbn3ZQWTfaOHTtKixYt9GPjNsYIGBdAoep/+fJlJQD0eQiqsmXLyqVLl/yMz4jXAkmnDWfboUOHcC7ntTFMoHXr1vLPf/5TadZ4lxhij4ARG5CuNjSKUD1Z0Hig2egAwVO5cmWpWLGiXzzOlypVSifjlgRCEkCHRvPmzeVf//pXyDQ8kZsA7LQJCQm5T0QhxqgAunbtmmVvQV2gzsMGg4D/Vrt371b7+HPixAllfG7VqpXs2bNHxcP+gxeKgQScEsB7hc6MU6dOOb0k7tPVrFlT6tevb4SDMQG0evVq2blzpxImmZmZqnKwv6DHKzs7WwkgaEdLliyR2bNnS2pqqmpqDRw4UNLT01UX/pw5c2TkyJFGwPAm3iCATo+UlBRZu3atNyrksVoU8Wkhhbosjzb0aq7w6QMbj93OgzQnT55UPWmhjNi4/tixY5KWlqbGC+n8uCUBEHj//feV9ty0adM7AhLJntc7KkAYF8Vy2QvdCI1eJnsINvgJaWrVqmVPxn0SKBCBTp06ycKFC9UwEPR6YnCs/YeBdxiBr8/hGOexxQ/a+uDBg6VBgwYFum9+iXUZICT0PVEG/PS99T7SID22upz454x0+pw+1nkgPWYfDB06VGrUqJFfcYyfL3QBZLzGvGFcEqhWrZr06tVLtm3bprRrdGTA2IotOkCwj1ng2OKHpht+eh8f8rx581Rc1apVlbDSwgNbCC8tQLDVx/Y4vY/0EBAQFrgH7qvvBQ1f3xNxOMZW/0qXLm1do8/h+mA/nMcPnTsQvrgW9h2UAz/0PCcmJkrnzp0jNq6uwC8XmmBeCUePHs3p0qWLo+r4QKHpmev385//PNf1wdIhLlhwmjZUOt7fPfx9Xfw5vulDOT67Zc6KFStyMjMzc71P+jn7OlVyfOaFHJ8wyPHZPEOmi+bz3759e86OHTtyfJ09Ie/vm4mg6rJv3z7r9dZ10FvrRAR24lYD8rHz8XQWopE2GnmiNk7zdZquIHkWJC3vb/79sw/ItPPHgF90EkFDgkaIGQuwpzZq1AiP1PE7pRIX8E/cCqACcmJyEvAsATTD9HQnVBJNw0OHDhmpr78F2MgteRMSIIFYJqCn3ZgoIwWQCcq8Bwm4iAAEkL2JFs2iUwBFky7zJgEXEkCvIKZAmQgUQCYo8x4k4CICEED4mQgUQCYo8x4k4CICbIK56GGxqCRAAndOgBrQnbPjlSTgSQLUgDz5WFkpEnAHAT3PzERpqQGZoMx7kICLCJw+fVr54zJRZAogE5R5DxJwEQEORHTRw2JRScCLBDgQ0YtPlXUiAZcQoAByyYNiMUnAawTYC+a1J8r6kICLCMBpmSnviTRCu+jFYFFJwAQBeF+Eh0UTgQLIBGXegwRcRoA2IJc9MBaXBLxCgN3wXnmSrAcJuJAAjdAufGgsMgl4hQBW0bAvkx7NetEGFE26zJsEXEjg0qVLcvHiRSMlpwAygpk3IQH3EGATzD3PiiUlAU8SYC+YJx8rK0UCJGAnwCaYnQb3SYAE1OKEGIxoIlAAmaDMe5CAiwhUr15dqlataqTEFEBGMPMmJOAeAhyI6J5nxZKSgOcIsBfMc4+UFSIB9xCgAHLPs2JJScCTBNgN78nHykqRQOwTOHnypMAxvYlAI7QJyrwHCbiIwK1bt+TGjRtGSkwBZAQzb0IC7iFAG5B7nhVLSgIkEAYBakBhwOOlJOBVAjRCe/XJsl4kEOMEKlasKBUqVDBSSmpARjDzJiTgHgKJiYlSrlw5IwWmADKCmTchAfcQoBHaPc+KJSUBTxKgDciTj5WVIoHYJwANyFQw2gS7efOmXL9+PWjdvvvuO8F5e8CAKAYSIAGzBPAd4ns0Ecwsf+iryaJFi6R8+fKya9cuKVOmjAwbNsyvfh988IG8+eabUrZsWbUqI0Zi/uAHP5B27drJlClTJCEhQa5duyb333+/TJo0ye9aHpAACUSOwIkTJ+TUqVORyzCPnIwIoIMHD8r+/fvlhRdekK5du8rjjz8u3bp1k7p161pFw1KwK1euVIIGkQsXLpRWrVrJvn37ZNasWVKrVi0rLXdIgASiR8BzRugNGzZIUlKSRSw5OVkOHDhgHWMH2g60HITz58/LmTNnlIC6ffu20oggiLBcCAMJkEB0CXjOBnTu3DnV7NLYMMjpwoUL+lBt7drQu+++K/369VPxsBlNnTpVaUF9+vSR9PR0v+t4QAIkEFkCJgWQkSbY5cuXxd6tV6xYMWXrCYbtyy+/VMLqrrvuUqfbt28vqampAiifffaZTJw4UXr37q2Og13POBIggfAJ2L/X8HMLnYORXjBoPPalXtGUqly5cq5Swfr+t7/9TZ544gnrHASRlsht27b106SsRNwhARKIGIHatWt7yyl969atZffu3RYgWNmbNWumtKK9e/da8e+99560bNlS9ZYhEr1emzZtss4fPXpUGa+1QLJOcIcESCBiBLAkD1opJoKRJhgE0NKlS2XJkiWSlZWlmlToiofXtdGjR6sueqxFPX/+fHnnnXesesMovXr1aiW80IWPrvkhQ4ZY57lDAiQQeQL4B2+qCVbEd6OccKpw9epV+frrr/16uULld/bsWdWEgvDRAb1cRYuGbgliMCLGJFSrVk31hunrgm2PHTsmaWlpkpGREew040iABBwQwD/6mTNnyvDhwx2kDi9JgTQgCJuNGzeqphHkFoQDutMbNmzoSABVqVIlV2nzEj5IDFWQY4ByYWMECUSNgEkNyLEA+uabb9TAQDisRhuxZMmSSgDBTrN48eKowWDGJEACZgnAHGJqzJ1jATRv3jy55557ZNu2bVKjRg2LCLSgMFtxVl7cIQESKHwCMSmAIGgGDhzoJ3yAypS1vPAfC0tAAvFBwGQvc2jrbwBrCB90nwcGjGheu3ZtYDSPSYAEXEzAVKvGcRNsx44dgjld3bt3l8aNGyu0mLJ//PhxGTFihItRs+gkQAJ2AiaN0I41IPRWQQNCdzimVmBkM36B0yzsFeE+CZCA+wiUKlUq3yEvkaqVYw0oJSVFXn75ZRk0aJDfvdEE27p1q18cD0iABNxLAMNegk2VikaNHAsgjESG8MGEUIwFQo9Y586dlUbUpUuXaJSNeZIACXicgGMBBA5Dhw6Vt99+W6lnmGCanZ2t3GPAyRgDCZCAdwhoO1C0e8Qc24CWLVsmW7ZsUYboK1euqDld0IQwdytY75h3HgVrQgLxScBET5hjAbR+/XpZvny5PPTQQ2oUNB7JfffdJ+PHj5fMzMz4fEKsNQl4lIDWgKJdPccCqFKlSgLreGDA7PavvvoqMJrHJEACLiWAaVf4rk0ExwKoY8eO8pvf/EbgkwcBY4A+/vhj5ToV7jYYSIAEvEFAL5EVU00wOI2/++67pUGDBgKPaXCp0aNHD+nQoYP07NnTG+RZCxIgAYuACQFUoF6wF198UTkTQ1c8Qps2bYTaj/W8uEMCniEQ7d4vDapAAggXNW/eXP10BvBqiN4wOIpnIAES8AYBU0boPAUQVqBAF/vkyZPl73//u/rBDxBmwMOTIdqKEEB/+ctfvEGdtSABEpDExETLL3u0ceQpgGrWrGnNCalXr55ynfrwww+rLdqHcN0IN6hw1cFAAiTgDQIVK1ZUAqjQbUD2eV+YCwYb0I9//GM/yvCchvXeGUiABLxDwFQTzHE3PJpc6AXDKqfQfJ5//nkZM2aMwHsaBicykAAJeIuACQ3IsQCaO3euLFiwQPmKxT7mhDVq1EgJIggkBhIgAe8QMNUL5lgAQdOZMGGCYA13rO/105/+VJ555hm1kinW7mIgARLwBgF0Lpny9e5YAJUrV04wCfX69etq7le3bt0UbfgN2b9/vzfIsxYkQAKCqRjo3TbRBMuzF8z+LDDOB243YAtCNzz2UVCsZmrKeZG9PNwnARKIHgFTRmjHAggOyD744ANZs2aNtG/fXnXTrVu3TtBlR39A0XsRmDMJFAYBUzYgxwIIEOCqsX///hYPzAXTI6Hr1KljxXOHBEjA3QRiQgPiSGh3v0QsPQmEQ6DQbUAcCR3O4+O1JOBOAvB2Ub16dSOFz7MJxpHQRp4Bb0ICMUWgePHiUqJECSO9YI674dH71bJlSzUB1U4L4wU4EtpOhPsk4H4CpmxAjgXQW2+9pQzQK1eu9KOLWfJ79uzxi+MBCZAACTgh4FgAHT58WP7whz9Ir169/PJt1qyZfPLJJ35xPCABEnA3gZjTgOCKtWzZsrmoYr14NM8YSIAEvEEA067g5cJEcKwBwSANx2NYDx4BSzL/+c9/FnTVt2vXzkRZeQ8SIAEDBPBtQwAVeje8va5VqlRRzucxGBHzwk6dOiVQ01566SWBw3oGEiAB7xAw1QTLsxs+EGe/fv0EjsnQ7Lp69aq0atVKmjZtGpiMxyRAAh4gEFMaEHhC68ESzfALPXjwYIX44MGDaqkeD/BmFUiABP5HABqQieDYBoSZ7xjvA7es8+bNs8o2Y8YMrg1v0eAOCbifABQM/ExoQI4FELwhvvbaa0oLwmx4Hdq2basclOljbkmABNxNAFOwMBUjpgQQLOOYCV+0aFG/VTAOHDggly9fdjdxlp4ESCAXgZgSQGh+TZ8+XW7evKm8IqK0O3fuVG5asUIqAwmQgHcIxJwNCC5Y4fsZ3fGzZs0SrBPWokULtT4854J558VjTUgABGKyGx52oEWLFqlueBQQtiC4akWzjIEESMBbBEw0wRyPA/r8889l06ZNamHCvn373hFpNN8we75UqVIFvh7jjnAdhV2B0fECEigQAe2UvkAX3WFixwIIvqDhgH7kyJF+t8ISHufPn5dq1ar5xQceQHMqX768WkW1TJkyMmzYML8kEDA9e/ZUo6whpLKzs2Xp0qVqaWisQwaXrxkZGcoQDrcgDCRAAtEhgG8ayoIJDchx22nUqFHSpEkTOXv2rF+tsSTP+vXr/eICDzBYEengvH706NGyatUqOXLkiF8yOEB6+umnJT09XQ12zMzMVJNfIfQw4x42qCFDhsjkyZP9ruMBCZBA5AmYsgE5FkBYEWP37t1qeWYIhAcffFDuu+8+6dy5sxq0lBcCTN1ISkqykiQnJwu67+0B0rZ06dJy7NgxtdyPPoeVN/R0j8aNG6tz0JAYSIAE3E/AcRPs3nvvFSzN89xzz6lmEVxwQFWDdpOfOw6sJ4/eMx0qVKigZtPrY2yvXbsmK1asUEJu8+bNgvuNHz9erUWPJhsC7D/Yx4z8SpUqqTj+IQESiDwBUxqQYwHUunVrGTt2rNJ47NWFMNi7d689Ktc+Bira25NY2DDQtxC0H7j2wDpjEEaPPvqobN++XbkFsAs4XKsFUq4bMYIESCBsAomJiQIlwf7Nhp1piAwcN8Fgo0FzCwIHAxBhJEZAQX/4wx+GyP77aKTRfoQQA18jgaupwhE2hA9CQkKCQOBhizj7tTh/J71ouI6BBEggfwL45vS3mH/q8FI4FkCQhr/85S8F0hEDENHr9eqrr+bb/ELxIExgP9LhxIkTyrCMPLX2hF42HbSNp3nz5srlh/Y5je5BxDGQAAlEl4CpJphjAYSeqylTpsgbb7yhDMgwDsMG9Lvf/S5fEhBAaEYtWbJEZs+eLampqaoZdebMGdUrBm0Kza5JkybJ4sWLZc6cOfLss8+qfAcOHKh6xiCgEB84DCDfmzMBCZDAHREw0QQr4rtJjpPSjRs3TuArNrAbfMyYMYIuensvV6j80IUP+43dhgPBpAcX4jyaVxgvZA9Ic/LkSTVDFzagUAE9aGlpaWq8UKg0jCcBEsifwEcffST333+/mnKVf+o7T+HYCA1XrPgFhgceeECwVI8TAWTvCdP5aOGD42DnEY80we6NcwwkQAKRJaAHIkY21+C5OW6CPfnkk3Lo0CE1QtKe1aeffqrsQjoOBmYMHmQgARJwJwHYWuH91GHjKKxKOtaAYJvB6GQMPqxfv766KYZrwzZ02Ldm2DvvvKNsQqdPn1aO6sMqFS8mARIodAIxJYAaNWqkJpI+9thjauQzbDFoGnXq1EmBQmGhukF62ptVhU6RBSABEigwAfSCmQiONSAYpDAQ8Sc/+Ume5bpx44Z88cUXeabhSRIggdgnYEIDcmwDwkDB/IQPkMKZdYcOHWKfLktIAiQQkkDMjQMKWVKeIAES8BSB2rVrCxzTmwiONSATheE9SIAECp8AWjsxtyxPKCxwJAZfPwwkQALeIWCqCebYCA20EDYbN25U0yZgoMKcLfj1adiwoaOBiN55PKwJCZBAJAg4FkDoXsda8JgSgZnxUNEggDCHC2OEGEiABLxDIOY0ICzHDIdk27Ztkxo1alikIYRMdNdZN+QOCZBAVAlgzid+Jr5rxxoQBA1mptuFDyjkNTk0qpSYOQmQQFQIYBVk+OAyIYAc94JB+MCPT2BAYdeuXRsYzWMSIAESyJeAYw1ox44dakHC7t27C5zDI2DqxfHjx2XEiBH53ogJSIAE3EPAlA3IsQaE+V3QgOAJET6eoaLhF+jv2T2IWVISIIG8CJhogjnWgFJSUuTll1+WQYMG+ZUZTbCtW7f6xfGABEjAvQTQww3HgDElgOClEMIHzS4YpLXxGV4Ir1y54l7aLDkJkIAfAUzDMOUA0HETDIMQ4YoDy+fgBymJH2bJM5AACXiLgCkbkOMm2Pvvvy9ff/21ckC2fPlyeeqpp2Tfvn1qVQvOfvfWy8fakIApAo41IMz3wgoYWBsMTuWxcikWD4QRGj8GEiAB7xAwpQE5FkBt2rSx/EGjjQhXrAjwHYsllRlIgAS8Q8CUAHLcBOvVq5cMHz5c6tatK3379lW+oeETGuu+v/DCC94hz5qQQJwTwLxP/EysjupYAOGZvPXWW9aj+fe//63W34JmpJ3UWye5QwIk4FoC6OnGL6a64UETza309HTV+zV48GDp37+/HDx40LWgWXASIIHgBEw1wRzbgKCSPfTQQ/Liiy8KZsbrMGPGjKBzxPR5bkmABNxJwIQG5FgALViwQF577TWlBbVv394i2rZtW7XmuxXBHRIgAdcTgAZkIjgWQJhygSYX5oRhJLQO8IjIbnhNg1sScD+BxMREqVSpkhEbkGMBhObX9OnTVVf89evXFeWdO3fKhAkTBIZoBhIgAW8QQO8XhFBMNcG6desmq1evlipVqsisWbOkXr160qJFC+nRo4eyDXkDPWtBAiQAAqaaYAXqhocdaNGiRcovEAoIW1Dv3r25FDPfWRLwGAFTvWAFEkAoFAYh4qcDfMfu2rVL2rVrp6O4JQEScDmBmBRA27dvlw8//FCthHH79m01WAnuOJ588kmX42bxSYAENAE9EBGr30Q7ONaAMPIZxuYGDRoIlm5NSEiQGzduKGEEX0EMJEAC3iCAMX/wfAE7b7SDYwH00UcfyYABA2TmzJnRLhPzJwESKGQCMdcEg4e0smXL5sICdQ0TUqtXr57rHCNIgARIIC8CjscBYe4XVkVdv369HD16VM2WPXz4sOqa/+KLL/K6B8+RAAm4jEDMaUAY7QxB8/rrr+dCCQ+JDCRAAt4hEHMCaP78+XLmzBnJzMxUPoGKFy+uesG++uor0SOjvYOfNSGB+CWATiYswYWe7mgHx0ZouOIYNWqUdOrUya9MderUkaysLL84HpAACbiXAJQLLDiBhSiiHRzbgIYMGSJHjhzJVZ5Lly4JuugZSIAEvEMg5ppgGzduFNh6MjIy5O6771brgmEcEFQ1uOlgIAES8BYBE5NRHTfB7rrrLrVaYpcuXQQqmh4JjTXCTLQVvfVoWRsSiG0C0IBMBMcCCI7H4A2xT58+fuXC+vCYC8ZAAiTgDQKY3wn/X/D9Fe3g+A7QdAKFDwpXoUIFgXByErCKRn49ZnRu5oQk05BA9AhA+Jw/f96IPyDHGlC41YUbD8wZg7aEhQ2HDRvmlyUmtf72t78VSF/Yln79619LSkqKLFu2TKZMmaLmnl27dk0tBT1p0iS/a3lAAiQQWQIxZ4QOp3pYOQMrq2L9sK5du8rjjz8ucHCGNcZ0gJF7/PjxgkUPIaz++Mc/KgGEGbmzfA7QMBWEgQRIwAwBUzYgx02wcKq9YcMGSUpKsrJITk4W+JK2Bzg3g5BBxR955BGlBcEKDwM3jN5Yhx5d/gwkQALRJ2BKAzIigDBZFc0uHWA3QjvTHuyTWTGuCJoSIMBmNHXqVKUFwQaFdckYSIAEokcAgxDxi6lu+HCqC8OyvTLFihULOrMe98jOzpZM33SPX/ziF+qW0IxSU1OVMPrss89k4sSJyg2sKRUxnHrzWhJwIwGYQaA0YPZDtIMRIzQ0HnTX64CmVOXKlfWhtYVrj7fffltGjBgh2hsbxh/pgN42uyal47klARKILAFPNcFat24tu3fvtghh9HSzZs2UVrR3714Vjy56ODsbOHCgWhIExxBUmzZtsq6DGxAYr6n9WEi4QwKuJmBEA4IAWrp0qVpBFRNX0aSCJnP69GkZPXq06vWaNm2a6nJfuHChEkwQQOiqh9CB8EIXPrrnMSeNgQRIILoETGlARXy2mZzoVuX/uZ89e1YJHnszCr1ceY24xCqsaItWq1ZN9Yb9P7fcexhLlJaWpuar5T7LGBIgAacE0DLB9/SjH/3I6SV3lM6IBqRLhkUNA0NewgdpYbDmGKBAajwmgegRgFN6CB8TuomRbvjooWLOJEACkSagl+WJdL7B8qMACkaFcSQQ5wRM2YAogOL8RWP1SSAUATbBQpFhPAmQQNQJUABFHTFvQAIkEEggMTEx6EDhwHSROGYTLBIUmQcJeIhAxYoVlQCiBuShh8qqkIDbCFAAue2Jsbwk4BECpqY7sQnmkReG1SCBSBJgN3wkaTIvEiABxwT0QEQ2wRwjY0ISIIFIEcBUDEwCNxHYBDNBmfcgARcSoAbkwofGIpOAVwhQAHnlSbIeJOAyAuwFc9kDY3FJwEsE2AvmpafJupCAiwjUrl1brdnHJpiLHhqLSgJeIYB1+EqVKkWHZF55oKwHCbiNAG1AbntiLC8JeIgAbUAeepisCgm4kQBtQG58aiwzCbicwMWLF9XKqCaqwZHQJijzHiTgIgIXLlxQAogakIseGotKAl4iQBuQl54m60ICJBCUAJtgQbEwkgTimwA1oPh+/qw9CRQagZIlS0pCQgIHIhbaE+CNSSCOCdSsWVNNxTCBgE0wE5R5DxJwGQE2wVz2wFhcEvAaAXbDe+2Jsj4k4BIC0IBMBDbBTFDmPUjAZQRMNcGKu4wLi0sCJBBlAnBKf+rUKfaCRZkzsycBEghCAMvyXL9+nQIoCBtGkQAJGCBAG5AByLwFCZBAcAKmbEA0Qgfnz1gSiHsC7IaP+1eAAEjAPIHExESpWrWqkRuzF8wIZt6EBNxDoGLFilK0aFEjRmgKIPe8FywpCUSUQEpKipw5c8Yvzy5dusi0adPEbgPavHmzDBgwwC/dmDFjZOTIkX5xd3JAAXQn1HgNCXiAwOeff+6oFq1bt5Z9+/Y5SlvQRDRCF5QY05NAHBCwa0DRrC4FUDTpMm8ScCEBDETEz0QvGJtgLnxBWGQSiCYBTMXIysqK5i2svI1qQDdv3lRDvK27B9kJlebq1aty+/btIFcwigRIINIETDXBjGlAixYtkvLly8uuXbukTJkyMmzYsFzMgqXBnJS5c+dKnTp1JCMjQ/r37y8tW7bMdS0jSIAEIkvARBPMiAZ08OBB2b9/v3Tt2lVGjx4tq1atkiNHjvjRCpVm/vz50qxZM+nWrZsMGTJEJk+e7HcdD0iABCJPwFMa0IYNGyQpKcmilJycLAcOHPDzOxsqzbp166RPnz7q2saNGwvap7du3ZJixYpZ+XGHBEggsgQggPCtbdmyRRmj7QMToRnhe8aI6XCDkSbYuXPnpEqVKlZZK1SoIFh90R5CpUE8mmwIgID9b7/9VipVqmS/nPskQAIRIlC7dm2BY/py5crJ6dOnlQCCQELAFrbYSNljjQigy5cv+3XpQXspW7asH65QaS5duuRXWVyrBZJfBjwgARKICIHixb8XCw0bNhT8ohmM2ICg8UBr0QFCpXLlyvpQbUOlwbwU+7VIXKpUKb9reUACJOBOAkYEEIZy79692yJ04sQJZVhGW3Lv3r0qPlSaVq1ayZ49e1QatEmbN29u5cMdEiABdxMwJoDQZlyyZInMnj1bUlNTVTMKE+HQK5adnS0QQMHSDBw4UNLT02XNmjUyZ86ciEyAc/cjY+lJwDsEivi0kBxT1Tl79qwSPHYbDoQOjMs6hEpz8uRJqV69ep69X8eOHZO0tDQ1Xkjnxy0JkEDBCFy8eFFNxbB3HBUsB+epjRihdXGCVcgufJAuVJpatWrpbLglARKIIgH0UKNVEuxbjPRt/696RDpn5kcCJEAC+RCgAMoHEE+TAAlEjwAFUPTYMmcSIIF8CBi1AeVTlrBPlyxZUq5duybDhw8POy9mQALxSgDfEKY7BQ4WvhMeLVq0kGeeeSbkpUZ7wUKWIoInvvzyS0FPGgMJkEDhE4AhO6+xe54TQIWPnCUgARJwSoA2IKekmI4ESCDiBCiAIo6UGZIACTglQAHklBTTkQAJRJwABVDEkTJDEiABpwTiVgDRyX3erwiG4sdTuHLlSq7qhlogIVR8rgxcHhGMSagq3en35KlxQKHg2OPp5P57GmPHjhUMWYCDNwib559/Xnr16qXcpiAeY6rgDnfcuHHKM56doZf2sUgC6rl8+XJZvHixVbVgCyTgZKh460KX79y4cUN5noD3CXhExHuCAAHTs2dPFYcxQnhnli5dKnBeFtaiEZgNH09h5syZOT7/06rKPj9DOYMGDYqn6lt1BYfA4Huxcp577rkc30A0deqvf/1rTrB0gde5+Xj9+vU5Pi8KOY8++qhVDZ+/8pyJEydax/369cs5fPhwTqh4K6EHdnxeJ3J8yzDn+Fzf5PgWgLBq5FuoUMVZEf/bCfd7irsmGP7bNW3aVEl1u5N7FRFHf0qXLi1wu4DVStCkQIDLE/x30x4nMYAMiwd4ObRt21a5gylRooRVzVALJISKty70wA5c3jRq1EjVxM7EJ28E7wxc3sAxoA7hfk9x1wSjk/vvX53//Oc/SrgcOnRIjRz/05/+pFzf2n01wR1u4OIB+sXz0haO1u1uYfJaIMHuoiLY4gpe4mJfeQbTM1asWKGa6Js3b5Z7771Xxo8fL+F+T3EngOjk/vtPZNSoUZZfbth53nvvPenQoYPf4gF6FRIvfVRO6hJqgYRQ8U7ydHsaaD++ZqngnxKEka/JKtu3b5dwv6e4a4LRyf33n4J9UYCUlBRJSEhQL5d9AQB8cPZ0bv+IQpUfzU77MjOhFkgIFR8qXzfHg4edCYzN+HYQ8K7AhXKwdwbndRMe+/mFuBNAdHIvarE5ezc7Vqnt0aOHWmwO60D5DI7qvcFqtXjRvB7wH93+sYVaICFUvBf5gAkEsw7oFdNBx8NGGO73VMynfo/TGcfDtl69evLuu+8q6b1s2TIZOnSoWrM+Huqu64ju1VdffVWg4ezcuVMaNGggDzzwgOqShwsGcIEmdPz4cXniiSfUYnT6Wq9tYQuDbQMrr0DDqVGjhuAdyczMFIyDgeEZHxk6LrBYX7B4rzFZvXq1qif+GeF9AA9wwhAExG3atEkGDBigvhucC+d7isvZ8Phv58TJvddeLHt9oAFBAFWrVs0erfZxDj+7wTVXojiICLZAAqodKt7rSFBvNK/Kly/vV9Vwvqe4FEB+9HhAAiRQaATizgZUaKR5YxIggVwEKIByIWEECZCAKQIUQKZI8z4kQAK5CFAA5ULCCBIgAVME4m4ktCmwvE/0CGD+GqYDZGVlCUZ0M7iXADUg9z67uC35iRMnZOrUqfLxxx/HLQOvVJwCyCtPMo7qgTlrGDhpn60dR9X3VFUpgDz1OOOnMhA+mJ/E4G4CFEDufn4xXXq4avj9738vjzzyiGzbtk369u2rfig0POxNmjRJnWvXrp3MmDFD1QUjsN944w012xrTHnwO0tQ0iN69e6vpALrCEEB2FxoLFy6UtLQ05eVRp+E29glQAMX+M3JtCTHnrFOnTrJy5UolVNB0wgxqBJ+3PenevbuahzVhwgS1nPaWLVvUUH8IG7j7/Mc//iEjRoyQDz/8UBmcn376aYuFXfhAeMEe9Oabb+a5Cqd1MXdihgB12Jh5FN4rCPxK62V57doPagpfw7oJ1aRJEzXvDP6ZMfETxxBUPleoyvEV0j/77LPys5/9DLtWwKzsl156SeDZcvr06VY8d9xDgALIPc/KlSXVmkqLFi38yo+udGhBiYmJkpycrGZd67RIiH37ZFjMVNeuY3VGmKH9ySefyFNPPaWjuHUZATbBXPbA3FZc7TvG7m8HdXjssceUB8bXX39dBg8eLHAFC9eoOkDY6GsRB4EEv8Q64Dw0pYyMDJk1a5ayFelz3LqHADUg9zwrV5YUy7wg6K3ehy9q+JpB+PTTT/0cnSMOTtECr7EfY3klHD/44IMC/zVdu3bFZTJlyhS15R93EIg7h2TueCzeKCU8Kk6bNk22bt2qnHvBKF2/fn3l+Ay+hF955RW1BlXHjh3V9vz588rmAwdXa9euVVpPUlKSVK1aVY18XrJkifJFg4GICxYsUEILzbSHH35YeXT81a9+pZymt2nTxtNrmXnj7fi+FvQH5KWn6bK6wOMgjM321RfCqQKabJHKK5xy8FrnBCiAnLNiShIggQgToBE6wkCZHQmQgHMCFEDOWTElCZBAhAlQAEUYKLMjARJwToACyDkrpiQBEogwAQqgCANldiRAAs4JUAA5Z8WUJEACESZAARRhoMyOBEjAOQEKIOesmJIESCDCBCiAIgyU2ZEACTgn8F94E5aJe3eQxwAAAABJRU5ErkJggg==" alt="\label{fig:core}Mean precision for identifying core and junk vertices for the Enron networks by using the row permutation test. The vertical lines separate the performance of identifying core vertices with low ranks from junk vertices with high ranks. The horizontal lines indicate the performance of a random classifier." width="0.5\textwidth" height="0.24\textheight" />
<p class="caption">
Figure 5.2: Mean precision for identifying core and junk vertices for the Enron networks by using the row permutation test. The vertical lines separate the performance of identifying core vertices with low ranks from junk vertices with high ranks. The horizontal lines indicate the performance of a random classifier.
</p>
</div>
</div>
</div>
<div id="sec:CE" class="section level2" number="5.2">
<h2><span class="header-section-number">5.2</span> Example: C. Elegans Network Data</h2>
<p>The <em>C. Elegans</em> networks consist of the chemical synapses network and the electrical synapses network of the roundworm, where each of 279 nodes represents a neuron and each edge represents the intensity of synapse connections between two neurons (<span class="citation">Chen et al. (2015)</span>).
Matching the chemical synapses network to the electrical synapses network is essential for understanding how the brain functions.
These networks are quite sparse with edge densities of 0.03 and 0.01 in each graph and the empirical correlation between two graphs is 0.1.</p>
<div id="a-challenging-task" class="section level3" number="5.2.1">
<h3><span class="header-section-number">5.2.1</span> A challenging task</h3>
<p>For simplicity, we made the networks unweighted and undirected for the experiments, and we assume the ground truth is known to be the identity.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb61-1"><a href="#cb61-1" tabindex="-1"></a>C1 <span class="ot">&lt;-</span> C.Elegans[[<span class="dv">1</span>]][] <span class="sc">&gt;</span> <span class="dv">0</span></span>
<span id="cb61-2"><a href="#cb61-2" tabindex="-1"></a>C2 <span class="ot">&lt;-</span> C.Elegans[[<span class="dv">2</span>]][] <span class="sc">&gt;</span> <span class="dv">0</span></span>
<span id="cb61-3"><a href="#cb61-3" tabindex="-1"></a><span class="fu">plot</span>(C1[], C2[])</span>
<span id="cb61-4"><a href="#cb61-4" tabindex="-1"></a>match <span class="ot">&lt;-</span> <span class="fu">gm</span>(C1, C2, <span class="at">start =</span> Matrix<span class="sc">::</span><span class="fu">Diagonal</span>(<span class="fu">nrow</span>(C1)))</span>
<span id="cb61-5"><a href="#cb61-5" tabindex="-1"></a><span class="fu">plot</span>(C1[], C2[], match)</span></code></pre></div>
<div class="figure"><span style="display:block;" id="fig:C-Elegans-edge"></span>
<img src="data:image/png;base64,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" alt="Edge discrepancies for the matched graphs with the true correspondence (left) and FW algorithm starting at the true correspondence (right). Green pixels represents an edge in the chemical graph while no edge in the electrical graph. Red pixels represent only an edge in the electrical graph. Grey pixels represent there is an edge in both graphs and white represents no edge in both graphs." /><img src="data:image/png;base64,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" alt="Edge discrepancies for the matched graphs with the true correspondence (left) and FW algorithm starting at the true correspondence (right). Green pixels represents an edge in the chemical graph while no edge in the electrical graph. Red pixels represent only an edge in the electrical graph. Grey pixels represent there is an edge in both graphs and white represents no edge in both graphs." />
<p class="caption">
Figure 5.3: Edge discrepancies for the matched graphs with the true correspondence (left) and FW algorithm starting at the true correspondence (right). Green pixels represents an edge in the chemical graph while no edge in the electrical graph. Red pixels represent only an edge in the electrical graph. Grey pixels represent there is an edge in both graphs and white represents no edge in both graphs.
</p>
</div>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" tabindex="-1"></a>nv <span class="ot">&lt;-</span> <span class="fu">nrow</span>(C1)</span>
<span id="cb62-2"><a href="#cb62-2" tabindex="-1"></a>id_match <span class="ot">&lt;-</span> <span class="fu">graphMatch</span>(<span class="fu">data.frame</span>(<span class="at">corr_A =</span> <span class="dv">1</span><span class="sc">:</span>nv, <span class="at">corr_B =</span> <span class="dv">1</span><span class="sc">:</span>nv), nv)</span>
<span id="cb62-3"><a href="#cb62-3" tabindex="-1"></a>i_sum <span class="ot">&lt;-</span> <span class="fu">summary</span>(id_match, C.Elegans[[<span class="dv">1</span>]], C.Elegans[[<span class="dv">2</span>]])</span>
<span id="cb62-4"><a href="#cb62-4" tabindex="-1"></a>m_sum <span class="ot">&lt;-</span> <span class="fu">summary</span>(match, C.Elegans[[<span class="dv">1</span>]], C.Elegans[[<span class="dv">2</span>]], id_match)</span>
<span id="cb62-5"><a href="#cb62-5" tabindex="-1"></a>i_emi <span class="ot">&lt;-</span> i_sum<span class="sc">$</span>edge_match_info</span>
<span id="cb62-6"><a href="#cb62-6" tabindex="-1"></a>m_emi <span class="ot">&lt;-</span> m_sum<span class="sc">$</span>edge_match_info</span></code></pre></div>
<p>Matching the <em>C. Elegans</em> networks is a challenging task.
Figures <a href="#fig:C-Elegans-edge">5.3</a> depict the edge discrepancies of two networks under the true alignment and the matching correspondence using <span class="smallcaps">FW</span> algorithm initialized at the true alignment.
The alignment found using <span class="smallcaps">FW</span> is not the identity with 112 out of 279 nodes correctly matched
and improves upon the identity in terms of the number of edge discrepancies.
For the true alignment, there are
116
edge errors and
1380
common edges while the alignment yielded by <span class="smallcaps">FW</span> initialized at the true correspondence has
270.5
edge errors and
1072
common edges.
Hence, this graph matching object does not have a solution at the true alignment.
One can try to use other objective functions to enhance the matching result, however we do not investigate this here.
Overall, while most performance measures are poor, our results illustrate the spectrum of challenges for graph matching.</p>
</div>
<div id="soft-matching-map3" class="section level3" number="5.2.2">
<h3><span class="header-section-number">5.2.2</span> Soft matching: MAP@3</h3>
<p>Considering matching <em>C. Elegans</em> graphs is quite challenging, let’s assume 20 pairs of vertices are known as seeds, which are chosen at random.
Accordingly, we generate a similarity matrix with 1’s corresponding to seeds, and the rest being barycenter.</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb63-1"><a href="#cb63-1" tabindex="-1"></a>seeds <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="fu">nrow</span>(C1), <span class="dv">20</span>)</span>
<span id="cb63-2"><a href="#cb63-2" tabindex="-1"></a>sim <span class="ot">&lt;-</span> <span class="fu">init_start</span>(<span class="at">start =</span> <span class="st">&quot;bari&quot;</span>, <span class="at">nns =</span> <span class="fu">nrow</span>(C1), <span class="at">soft_seeds =</span> seeds)</span></code></pre></div>
<p>In addition to one-on-one matching, we will also conduct soft matching, which is to find three most promising matches to each non-seed vertex.
We achieve the goal of soft matching by finding the top 3 largest values in each row of the doubly stochastic matrix from the last iteration of <span class="smallcaps">Frank Wolfe</span> methodology with indefinite relaxation and <span class="smallcaps">PATH</span> algorithm, as well as the normalized matrix from the last iteration of the power method for <span class="smallcaps">IsoRank</span> algorithm.
To evaluate the matching performance, we will look at both matching precision: <span class="math inline">\(precision=\frac{1}{n_m-s}\sum_{i\in V_m\setminus S}P_{ii}\)</span>, and Mean Average Precision @ 3 (MAP@ 3):<span class="math inline">\(MAP@3 = \frac{1}{n_m-s}\sum_{i\in V_m\setminus S}1_{\{i\in T_i\}}\)</span>, where <span class="math inline">\(T_i\)</span> is the set of 3 most promising matches to node <span class="math inline">\(i\)</span>.</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb64-2"><a href="#cb64-2" tabindex="-1"></a>m_FW <span class="ot">&lt;-</span> <span class="fu">gm</span>(<span class="at">A =</span> C1, <span class="at">B =</span> C2, <span class="at">seeds =</span> seeds, </span>
<span id="cb64-3"><a href="#cb64-3" tabindex="-1"></a>           <span class="at">similarity =</span> sim, <span class="at">method =</span> <span class="st">&quot;indefinite&quot;</span>,</span>
<span id="cb64-4"><a href="#cb64-4" tabindex="-1"></a>           <span class="at">start =</span> <span class="st">&quot;bari&quot;</span>, <span class="at">max_iter =</span> <span class="dv">100</span>)</span>
<span id="cb64-5"><a href="#cb64-5" tabindex="-1"></a>m_PATH <span class="ot">&lt;-</span> <span class="fu">gm</span>(<span class="at">A =</span> C1, <span class="at">B =</span> C2, <span class="at">seeds =</span> seeds,</span>
<span id="cb64-6"><a href="#cb64-6" tabindex="-1"></a>             <span class="at">similarity =</span> <span class="cn">NULL</span>, <span class="at">method =</span> <span class="st">&quot;PATH&quot;</span>,</span>
<span id="cb64-7"><a href="#cb64-7" tabindex="-1"></a>             <span class="at">epsilon =</span> <span class="dv">1</span>, <span class="at">tol =</span> <span class="fl">1e-05</span>)</span>
<span id="cb64-8"><a href="#cb64-8" tabindex="-1"></a>m_Iso <span class="ot">&lt;-</span> <span class="fu">gm</span>(<span class="at">A =</span> C1, <span class="at">B =</span> C2, <span class="at">seeds =</span> seeds,</span>
<span id="cb64-9"><a href="#cb64-9" tabindex="-1"></a>             <span class="at">similarity =</span> <span class="fu">as.matrix</span>(sim), <span class="at">method =</span> <span class="st">&quot;IsoRank&quot;</span>,</span>
<span id="cb64-10"><a href="#cb64-10" tabindex="-1"></a>             <span class="at">max_iter =</span> <span class="dv">50</span>, <span class="at">lap_method =</span> <span class="st">&quot;LAP&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb65"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb65-1"><a href="#cb65-1" tabindex="-1"></a>match_eval <span class="ot">&lt;-</span> <span class="cf">function</span>(match){</span>
<span id="cb65-2"><a href="#cb65-2" tabindex="-1"></a>  precision <span class="ot">&lt;-</span> <span class="fu">mean</span>(match<span class="sc">$</span>corr_A <span class="sc">==</span> match<span class="sc">$</span>corr_B) </span>
<span id="cb65-3"><a href="#cb65-3" tabindex="-1"></a>  order <span class="ot">&lt;-</span> <span class="fu">apply</span>(match<span class="sc">$</span>soft, <span class="at">MARGIN =</span> <span class="dv">1</span>, <span class="at">FUN =</span> order, <span class="at">decreasing =</span> <span class="cn">TRUE</span>)</span>
<span id="cb65-4"><a href="#cb65-4" tabindex="-1"></a>  top3 <span class="ot">&lt;-</span> <span class="fu">t</span>(order[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>,]) <span class="sc">-</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">ncol</span>(order) </span>
<span id="cb65-5"><a href="#cb65-5" tabindex="-1"></a>  MAP3 <span class="ot">&lt;-</span> <span class="fu">mean</span>(<span class="fu">apply</span>(top3, <span class="at">MARGIN =</span> <span class="dv">1</span>, <span class="at">FUN =</span> <span class="cf">function</span>(v){<span class="dv">0</span> <span class="sc">%in%</span> v}))</span>
<span id="cb65-6"><a href="#cb65-6" tabindex="-1"></a>  </span>
<span id="cb65-7"><a href="#cb65-7" tabindex="-1"></a>  <span class="fu">round</span>(<span class="fu">data.frame</span>(precision, MAP3),<span class="dv">4</span>)</span>
<span id="cb65-8"><a href="#cb65-8" tabindex="-1"></a>}</span>
<span id="cb65-9"><a href="#cb65-9" tabindex="-1"></a></span>
<span id="cb65-10"><a href="#cb65-10" tabindex="-1"></a><span class="fu">sapply</span>(<span class="fu">list</span>(m_FW, m_PATH, m_Iso), match_eval) <span class="sc">%&gt;%</span> </span>
<span id="cb65-11"><a href="#cb65-11" tabindex="-1"></a>  knitr<span class="sc">::</span><span class="fu">kable</span>(<span class="at">col.names =</span> <span class="fu">c</span>(<span class="st">&quot;Frank Wolfe&quot;</span>, <span class="st">&quot;PATH&quot;</span>, <span class="st">&quot;IsoRank&quot;</span>), </span>
<span id="cb65-12"><a href="#cb65-12" tabindex="-1"></a>               <span class="at">booktabs =</span> <span class="cn">TRUE</span>, <span class="at">digits =</span> <span class="dv">2</span>)</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">Frank Wolfe</th>
<th align="left">PATH</th>
<th align="left">IsoRank</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">precision</td>
<td align="left">0.0932</td>
<td align="left">0.0968</td>
<td align="left">0.0789</td>
</tr>
<tr class="even">
<td align="left">MAP3</td>
<td align="left">0.1039</td>
<td align="left">0.1147</td>
<td align="left">0.0824</td>
</tr>
</tbody>
</table>
<p>MAP@ 3 is slightly higher than precision for each method.
Soft matching provides an alternative way of matching by generating a set of promising matching candidates.</p>
</div>
</div>
<div id="sec:Transp" class="section level2" number="5.3">
<h2><span class="header-section-number">5.3</span> Example: Britain Transportation Network</h2>
<p>To demonstrate matching multi-layer networks-layers, we consider two graphs derived from the Britain Transportation network (<span class="citation">Riccardo and Marc (2015)</span>).
The network reflects the transportation connections in the UK, with five layers representing ferry, rail, metro, coach, and bus.
A smaller template graph was constructed based on a random walk starting from a randomly chosen hub node, a node that has connections in all the layers.
The template graph has 53 nodes and 56 connections in total and is an induced subgraph of the original graph.</p>
<p>Additionally, based on filter methods from , the authors of that paper also provided a list of candidate matches for each template node, where the true correspondence is guaranteed to be among the candidates.
The number of candidates ranges from 3 to 1059 at most, with an average of 241 candidates for each template vertex.
Thus, we made an induced subgraph from the transportation network with only candidates, which gave us the world graph with 2075 vertices and 8368 connections.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" tabindex="-1"></a>tm <span class="ot">&lt;-</span> Transportation[[<span class="dv">1</span>]]</span>
<span id="cb66-2"><a href="#cb66-2" tabindex="-1"></a>cm <span class="ot">&lt;-</span> Transportation[[<span class="dv">2</span>]]</span>
<span id="cb66-3"><a href="#cb66-3" tabindex="-1"></a>candidate <span class="ot">&lt;-</span> Transportation[[<span class="dv">3</span>]]</span></code></pre></div>
<p>Figure <span class="math inline">\(\ref{Fig:trans_net}\)</span> visualizes the transportation connections for the induced subgraphs, where means of transportation are represented by different colors.
Note that all edges in the template are common edges shared by two graphs,
where 40%, 24.1%, 37.5%, 31.7% and 25.6% of edges in the world graph are in template for each layer.
All graphs are unweighted, directed, and do not have self-loops.
Tables <a href="#tab:edge-summary-trans">5.3</a> further displays an overview and edge summary regarding each layer of the Britain Transportation Network.
A true correspondence exists for each template vertex in the world graph, our goal is to locate each template vertex in the Britain Transportation network by matching two multi-layer graphs with different number of vertices.</p>
<table>
<caption><span id="tab:edge-summary-trans">Table 5.3: </span>Overview of the Britain Transportation Network layers. Correlation is calculted using the template graph and the aligned induced subgraph of the world graph. The final three columns indicate the number of common edges, missing edges, and extra edges in the aligned subgraph of the world graph.</caption>
<thead>
<tr class="header">
<th align="left">Layer</th>
<th align="left"># Nodes</th>
<th align="left"># Edges</th>
<th align="right">Correlation</th>
<th align="right">Common</th>
<th align="right">Missing</th>
<th align="right">Extra</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Ferry</td>
<td align="left">53 / 2075</td>
<td align="left">10 / 42</td>
<td align="right">0.63</td>
<td align="right">10</td>
<td align="right">0</td>
<td align="right">15</td>
</tr>
<tr class="even">
<td align="left">Rail</td>
<td align="left">53 / 2075</td>
<td align="left">14 / 4185</td>
<td align="right">0.49</td>
<td align="right">14</td>
<td align="right">0</td>
<td align="right">44</td>
</tr>
<tr class="odd">
<td align="left">Metro</td>
<td align="left">53 / 2075</td>
<td align="left">9 / 445</td>
<td align="right">0.61</td>
<td align="right">9</td>
<td align="right">0</td>
<td align="right">15</td>
</tr>
<tr class="even">
<td align="left">Coach</td>
<td align="left">53 / 2075</td>
<td align="left">13 / 2818</td>
<td align="right">0.56</td>
<td align="right">13</td>
<td align="right">0</td>
<td align="right">28</td>
</tr>
<tr class="odd">
<td align="left">Bus</td>
<td align="left">53 / 2075</td>
<td align="left">10 / 878</td>
<td align="right">0.50</td>
<td align="right">10</td>
<td align="right">0</td>
<td align="right">29</td>
</tr>
</tbody>
</table>
<div class="figure"><span style="display:block;" id="fig:unnamed-chunk-2"></span>
<img src="data:image/png;base64,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" alt="\label{Fig:trans_net} Visualization of the template graph (left) and the world graph (right) with corresponding vertices, both derived from the Britain Transportation network with five layers: ferry, rail, metro, coach, and bus. Edges represent transportation transactions and each color indicates a different means of transportation from a different layer of network." width="47.5%" /><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAYAAAAUg66AAAAEDmlDQ1BrQ0dDb2xvclNwYWNlR2VuZXJpY1JHQgAAOI2NVV1oHFUUPpu5syskzoPUpqaSDv41lLRsUtGE2uj+ZbNt3CyTbLRBkMns3Z1pJjPj/KRpKT4UQRDBqOCT4P9bwSchaqvtiy2itFCiBIMo+ND6R6HSFwnruTOzu5O4a73L3PnmnO9+595z7t4LkLgsW5beJQIsGq4t5dPis8fmxMQ6dMF90A190C0rjpUqlSYBG+PCv9rt7yDG3tf2t/f/Z+uuUEcBiN2F2Kw4yiLiZQD+FcWyXYAEQfvICddi+AnEO2ycIOISw7UAVxieD/Cyz5mRMohfRSwoqoz+xNuIB+cj9loEB3Pw2448NaitKSLLRck2q5pOI9O9g/t/tkXda8Tbg0+PszB9FN8DuPaXKnKW4YcQn1Xk3HSIry5ps8UQ/2W5aQnxIwBdu7yFcgrxPsRjVXu8HOh0qao30cArp9SZZxDfg3h1wTzKxu5E/LUxX5wKdX5SnAzmDx4A4OIqLbB69yMesE1pKojLjVdoNsfyiPi45hZmAn3uLWdpOtfQOaVmikEs7ovj8hFWpz7EV6mel0L9Xy23FMYlPYZenAx0yDB1/PX6dledmQjikjkXCxqMJS9WtfFCyH9XtSekEF+2dH+P4tzITduTygGfv58a5VCTH5PtXD7EFZiNyUDBhHnsFTBgE0SQIA9pfFtgo6cKGuhooeilaKH41eDs38Ip+f4At1Rq/sjr6NEwQqb/I/DQqsLvaFUjvAx+eWirddAJZnAj1DFJL0mSg/gcIpPkMBkhoyCSJ8lTZIxk0TpKDjXHliJzZPO50dR5ASNSnzeLvIvod0HG/mdkmOC0z8VKnzcQ2M/Yz2vKldduXjp9bleLu0ZWn7vWc+l0JGcaai10yNrUnXLP/8Jf59ewX+c3Wgz+B34Df+vbVrc16zTMVgp9um9bxEfzPU5kPqUtVWxhs6OiWTVW+gIfywB9uXi7CGcGW/zk98k/kmvJ95IfJn/j3uQ+4c5zn3Kfcd+AyF3gLnJfcl9xH3OfR2rUee80a+6vo7EK5mmXUdyfQlrYLTwoZIU9wsPCZEtP6BWGhAlhL3p2N6sTjRdduwbHsG9kq32sgBepc+xurLPW4T9URpYGJ3ym4+8zA05u44QjST8ZIoVtu3qE7fWmdn5LPdqvgcZz8Ww8BWJ8X3w0PhQ/wnCDGd+LvlHs8dRy6bLLDuKMaZ20tZrqisPJ5ONiCq8yKhYM5cCgKOu66Lsc0aYOtZdo5QCwezI4wm9J/v0X23mlZXOfBjj8Jzv3WrY5D+CsA9D7aMs2gGfjve8ArD6mePZSeCfEYt8CONWDw8FXTxrPqx/r9Vt4biXeANh8vV7/+/16ffMD1N8AuKD/A/8leAvFY9bLAAAAOGVYSWZNTQAqAAAACAABh2kABAAAAAEAAAAaAAAAAAACoAIABAAAAAEAAAEgoAMABAAAAAEAAAEgAAAAAKtAJY0AADm5SURBVHgB7Z0HWFTX1oY/ZmAYegepYkex94K9l1gSS+yaWKImmmLUJJYYTUyx5I81auxdY40au0bsglhQAUFFQEB6Z2DgX/twNbbkTnI5zKBrPw8wZZ9d3nP83GWttY0KKYETE2ACTEAPBBR6qJOrZAJMgAlIBFiA+EFgAkxAbwRYgPSGnitmAkyABYifASbABPRGgAVIb+i5YibABFiA+BlgAkxAbwRYgPSGnitmAkyABYifASbABPRGgAVIb+i5YibABFiA+BlgAkxAbwRYgPSGnitmAkyABYifASbABPRGgAVIb+i5YibABFiA+BlgAkxAbwRYgPSGnitmAkyABYifASbABPRGgAVIb+i5YibABFiA+BlgAkxAbwRYgPSGnitmAkyABYifASbABPRGgAVIb+i5YibABFiA+BlgAkxAbwRYgPSGnitmAkyABYifASbABPRGgAVIb+i5YibABFiA+BlgAkxAbwRYgPSGnitmAkyABYifASbABPRGgAVIb+i5YibABFiA+BlgAkxAbwRYgPSGnitmAkyABYifASbABPRGgAVIb+i5YibABFiA+BlgAkxAbwRYgPSGnitmAkyABYifASbABPRGgAVIb+i5YibABFiA+BlgAkxAbwRYgPSGnitmAkyABYifASbABPRGgAVIb+i5YibABFiA+BlgAkxAbwRYgPSGnitmAkyABYifASbABPRGgAVIb+i5YibABFiA+BlgAkxAbwRYgPSGnitmAkyABYifASbABPRGgAVIb+i5YibABFiA+BlgAkxAbwRYgPSGnitmAkyABYifASbABPRGgAVIb+i5YibABFiA+BlgAkxAbwRYgPSGnitmAkyA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" alt="\label{Fig:trans_net} Visualization of the template graph (left) and the world graph (right) with corresponding vertices, both derived from the Britain Transportation network with five layers: ferry, rail, metro, coach, and bus. Edges represent transportation transactions and each color indicates a different means of transportation from a different layer of network." width="47.5%" />
<p class="caption">
Figure 5.4:  Visualization of the template graph (left) and the world graph (right) with corresponding vertices, both derived from the Britain Transportation network with five layers: ferry, rail, metro, coach, and bus. Edges represent transportation transactions and each color indicates a different means of transportation from a different layer of network.
</p>
</div>
<p>Based on the candidates, we specify a start matrix that is row-stochastic which can be used for the argument in the graph matching function for <span class="smallcaps">FW</span> methodology.
For each row node, its value is either zero or the inverse of the number of candidates for that node.
To ensure that template nodes only get matched to candidates, we constructed a similarity score matrix by taking the start matrix <span class="math inline">\(\times 10^5\)</span>, so that a high similarity score is assigned to all the template-candidate pairs.</p>
<p>Then we match the template graph with the world graph using <span class="smallcaps">Percolation</span> algorithm.
The template graph stored in and world graph are lists of 5 matrices of dimensions 53 and 2075 respectively.
Since we have no information on seeds, we assign to the argument, the <span class="smallcaps">Percolation</span> algorithm will initialize the mark matrix using prior information in the similarity score matrix.</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb67-1"><a href="#cb67-1" tabindex="-1"></a>match <span class="ot">&lt;-</span> <span class="fu">gm</span>(<span class="at">A =</span> tm, <span class="at">B =</span> cm, <span class="at">similarity =</span> similarity, </span>
<span id="cb67-2"><a href="#cb67-2" tabindex="-1"></a>            <span class="at">method =</span> <span class="st">&quot;percolation&quot;</span>, <span class="at">r =</span> <span class="dv">4</span>)</span>
<span id="cb67-3"><a href="#cb67-3" tabindex="-1"></a><span class="fu">summary</span>(match, tm, cm)</span></code></pre></div>
<pre><code>## Call: gm(A = tm, B = cm, similarity = similarity, method = &quot;percolation&quot;, 
##     r = 4)
## 
## # Matches: 53, # Seeds:  0, # Vertices:  53, 2075
##          layer    1    2    3    4    5
##   common_edges 10.0 13.0  9.0 11.0 10.0
##  missing_edges  0.0  1.0  0.0  2.0  0.0
##    extra_edges 22.0 36.0 21.0 24.0 35.0
##          fnorm  4.7  6.1  4.6  5.1  5.9</code></pre>
<p>The function outputs edge statistics and objective function values for each layer separately.
To further improve matching performance, one can replicate all the analysis in the first example on Enron dataset, such as using the centering scheme and adaptive seeds.
Finally, one can refer to the match report to compare matching performance and pick the best one.</p>
</div>
</div>
<div id="sec:conclusion" class="section level1" number="6">
<h1><span class="header-section-number">6</span> Conclusions</h1>
<p>In this work, we detail the methods and usage of the R package <code>iGraphMatch</code> for finding and assessing an alignment between the vertex sets of two edge-correlated graphs.
The package implements common steps for the analysis of graph matching: seamless matching of generalized graphs, evaluation of matching performance, and visualization.
For each of the graph matching methodologies, we provide versatile options for the form of input graphs and the specification of available prior information.
Through the discussion in section <span class="math inline">\(\ref{sec:example}\)</span>, we demonstrate the broad functionality and flexibility of the package by analyzing diverse graph matching problems on real data step by step.
The package also provides tools for simulating correlated graphs which can be used in the development and enhancement of graph matching methods.</p>
<p>Methods for graph matching are still under active development.
We plan to include other novel methods as the field continues to develop.
In the short term we are looking to introduce a suite of additional matching methods that have recently been proposed in the literature.</p>
<p>One of the biggest challenges for graph matching is evaluating the quality of a match, especially at the vertex level.
This has received minimal attention in the previous literature.
We provide measures of goodness of matching on the vertex level and demonstrate their effectiveness empirically.
These baseline methods implement a permutation testing framework for assessing matches that can be readily extended to other metrics.</p>
<p>The primary authors for the package are Vince Lyzinski, Zihuan Qiao, and Daniel Sussman.
Joshua Agterberg, Lujia Wang, and Yixin Kong also provided important contributions.
We also want to thank all of our users, especially Youngser Park, for their feedback and patience as we continue to develop the package.</p>
<p>This work was supported in part by grants from DARPA (FA8750-20-2-1001 and FA8750-18-0035) and from MIT Lincoln Labs.</p>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-relax_paper" class="csl-entry">
Aflalo, Yonathan, Alexander Bronstein, and Ron Kimmel. 2015b. <span>“On Convex Relaxation of Graph Isomorphism.”</span> <em>Proceedings of the National Academy of Sciences</em> 112 (10): 2942–47. <a href="https://doi.org/10.1073/pnas.1401651112">https://doi.org/10.1073/pnas.1401651112</a>.
</div>
<div id="ref-friendly" class="csl-entry">
———. 2015a. <span>“On Convex Relaxation of Graph Isomorphism.”</span> <em>Proceedings of the National Academy of Sciences</em> 112 (10): 2942–47. <a href="https://doi.org/10.1073/pnas.1401651112">https://doi.org/10.1073/pnas.1401651112</a>.
</div>
<div id="ref-SimilarityScore" class="csl-entry">
Belongie, S., J. Malik, and J. Puzicha. 2002. <span>“Shape Matching and Object Recognition Using Shape Contexts.”</span> <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em> 24 (4): 509–22. <a href="https://doi.org/10.1109/34.993558">https://doi.org/10.1109/34.993558</a>.
</div>
<div id="ref-PatternRec1" class="csl-entry">
Berg, A. C., T. L. Berg, and J. Malik. 2005. <span>“Shape Matching and Object Recognition Using Low Distortion Correspondences”</span> 1: 26–33 vol. 1. <a href="https://doi.org/10.1109/CVPR.2005.320">https://doi.org/10.1109/CVPR.2005.320</a>.
</div>
<div id="ref-AP" class="csl-entry">
Burkard, Rainer, Mauro Dell’Amico, and Silvano Martello. 2009. <em>Assignment Problems</em>. Philadelphia, PA, USA: Society for Industrial; Applied Mathematics.
</div>
<div id="ref-PatternRec2" class="csl-entry">
Caelli, T., and S. Kosinov. 2004. <span>“An Eigenspace Projection Clustering Method for Inexact Graph Matching.”</span> <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em> 26 (4): 515–19. <a href="https://doi.org/10.1109/TPAMI.2004.1265866">https://doi.org/10.1109/TPAMI.2004.1265866</a>.
</div>
<div id="ref-neuro" class="csl-entry">
Chen, Li, Joshua T. Vogelstein, Vince Lyzinski, and Carey E. Priebe. 2015. <span>“A Joint Graph Inference Case Study: The c.elegans Chemical and Electrical Connectomes.”</span> <a href="https://arxiv.org/abs/1507.08376">https://arxiv.org/abs/1507.08376</a>.
</div>
<div id="ref-community_detection" class="csl-entry">
Clauset, Aaron, M. E. J. Newman, and Cristopher Moore. 2004. <span>“Finding Community Structure in Very Large Networks.”</span> <em>Physical Review E</em> 70 (6). <a href="https://doi.org/10.1103/physreve.70.066111">https://doi.org/10.1103/physreve.70.066111</a>.
</div>
<div id="ref-PatternRec3" class="csl-entry">
Conte, Donatello, Pasquale Foggia, Mario Vento, and Carlo Sansone. 2004. <span>“<span>Thirty Years Of Graph Matching In Pattern Recognition</span>.”</span> <em><span>International Journal of Pattern Recognition and Artificial Intelligence</span></em> 18 (3): 265–98. <a href="https://doi.org/10.1142/S0218001404003228">https://doi.org/10.1142/S0218001404003228</a>.
</div>
<div id="ref-ML2" class="csl-entry">
Cour, Timothee, Praveen Srinivasan, and Jianbo Shi. 2007. <span>“Balanced Graph Matching.”</span> Edited by B. Schölkopf, J. C. Platt, and T. Hoffman, 313–20. <a href="http://papers.nips.cc/paper/2960-balanced-graph-matching.pdf">http://papers.nips.cc/paper/2960-balanced-graph-matching.pdf</a>.
</div>
<div id="ref-igraph" class="csl-entry">
Csardi, Gabor, and Tamas Nepusz. 2006. <span>“The Igraph Software Package for Complex Network Research.”</span> <em>InterJournal</em> Complex Systems: 1695. <a href="https://igraph.org">https://igraph.org</a>.
</div>
<div id="ref-GRAMPA" class="csl-entry">
Fan, Zhou, Cheng Mao, Yihong Wu, and Jiaming Xu. 2020. <span>“Spectral Graph Matching and Regularized Quadratic Relaxations: Algorithm and Theory.”</span> In <em>Proceedings of the 37th International Conference on Machine Learning</em>, edited by Hal Daumé III and Aarti Singh, 119:2985–95. Proceedings of Machine Learning Research. PMLR. <a href="https://proceedings.mlr.press/v119/fan20a.html">https://proceedings.mlr.press/v119/fan20a.html</a>.
</div>
<div id="ref-soft_seeding" class="csl-entry">
Fang, Fei, Daniel Sussman, and Vince Lyzinski. 2018. <span>“Tractable Graph Matching via Soft Seeding,”</span> July.
</div>
<div id="ref-QAP" class="csl-entry">
Finke, Gerd, Rainer E. Burkard, and Franz Rendl. 1987. <span>“Quadratic Assignment Problems.”</span> In <em>Surveys in Combinatorial Optimization</em>, edited by Silvano Martello, Gilbert Laporte, Michel Minoux, and Celso Ribeiro, 132:61–82. North-Holland Mathematics Studies. North-Holland. https://doi.org/<a href="https://doi.org/10.1016/S0304-0208(08)73232-8">https://doi.org/10.1016/S0304-0208(08)73232-8</a>.
</div>
<div id="ref-FW" class="csl-entry">
Frank, Marguerite, and Philip Wolfe. 1956. <span>“An Algorithm for Quadratic Programming.”</span> <em>Naval Research Logistics Quarterly</em> 3 (1‐2): 95–110. <a href="https://EconPapers.repec.org/RePEc:wly:navlog:v:3:y:1956:i:1-2:p:95-110">https://EconPapers.repec.org/RePEc:wly:navlog:v:3:y:1956:i:1-2:p:95-110</a>.
</div>
<div id="ref-SBM" class="csl-entry">
Holland, Paul, Kathryn Laskey, and Samuel Leinhardt. 1983. <span>“Stochastic Blockmodels: First Steps.”</span> <em>Social Networks - SOC NETWORKS</em> 5 (June): 109–37. <a href="https://doi.org/10.1016/0378-8733(83)90021-7">https://doi.org/10.1016/0378-8733(83)90021-7</a>.
</div>
<div id="ref-Hu2018-hd" class="csl-entry">
Hu, S, L Zou, J X Yu, H Wang, and D Zhao. 2018. <span>“Answering Natural Language Questions by Subgraph Matching over Knowledge Graphs.”</span> <em>IEEE Transactions on Knowledge and Data Engineering</em> 30 (5): 824–37.
</div>
<div id="ref-Corbi" class="csl-entry">
Huang, Qiang, Ling-Yun Wu, and Xiang-Sun Zhang. 2013. <span>“Corbi: A New r Package for Biological Network Alignment and Querying.”</span>
</div>
<div id="ref-bio2" class="csl-entry">
Ito, Takashi, Tomoko Chiba, Ritsuko Ozawa, Mikio Yoshida, Masahira Hattori, and Yoshiyuki Sakaki. 2001. <span>“A Comprehensive Two-Hybrid Analysis to Explore the Yeast Protein Interactome.”</span> <em>Proceedings of the National Academy of Sciences</em> 98 (8): 4569–74. <a href="https://doi.org/10.1073/pnas.061034498">https://doi.org/10.1073/pnas.061034498</a>.
</div>
<div id="ref-lap_solver" class="csl-entry">
Jonker, Roy, and Ton Volgenant. 1988. <span>“A Shortest Augmenting Path Algorithm for Dense and Sparse Linear Assignment Problems.”</span> In <em>DGOR/NSOR</em>, edited by Helmut Schellhaas, Paul van Beek, Heinz Isermann, Reinhart Schmidt, and Mynt Zijlstra, 622–22. Berlin, Heidelberg: Springer Berlin Heidelberg.
</div>
<div id="ref-ExpandWhenStuck" class="csl-entry">
Kazemi, Ehsan, S Hamed Hassani, and Matthias Grossglauser. 2015. <span>“Growing a Graph Matching from a Handful of Seeds.”</span> <em>Proceedings of the VLDB Endowment</em> 8 (June): 1010–21. <a href="https://doi.org/10.14778/2794367.2794371">https://doi.org/10.14778/2794367.2794371</a>.
</div>
<div id="ref-BLAST" class="csl-entry">
Kelley, Brian, Bingbing Yuan, Fran Lewitter, Roded Sharan, Brent Stockwell, and Trey Ideker. 2004. <span>“PathBLAST: A Tool for Alignment of Protein Interaction Networks.”</span> <em>Nucleic Acids Research</em> 32 (August): W83–8.
</div>
<div id="ref-multilayer" class="csl-entry">
Kivelä, Mikko, Alex Arenas, Marc Barthelemy, James P. Gleeson, Yamir Moreno, and Mason A. Porter. 2014. <span>“<span class="nocase">Multilayer networks</span>.”</span> <em>Journal of Complex Networks</em> 2 (3): 203–71.
</div>
<div id="ref-measure" class="csl-entry">
Kuchaiev, Oleksii, and Natasa Przulj. 2011. <span>“Integrative Network Alignment Reveals Large Regions of Global Network Similarity in Yeast and Human.”</span> <em>Bioinformatics (Oxford, England)</em> 27 (March): 1390–96.
</div>
<div id="ref-Hungarian" class="csl-entry">
Kuhn, H. W. 1955. <span>“The Hungarian Method for the Assignment Problem.”</span> <em>Naval Res. Logist. Quart.</em> 2 (January): 83–98. <a href="https://doi.org/10.1002/nav.20053">https://doi.org/10.1002/nav.20053</a>.
</div>
<div id="ref-Enron" class="csl-entry">
Leskovec, Jure, Kevin J. Lang, Anirban Dasgupta, and Michael W. Mahoney. 2008. <span>“Community Structure in Large Networks: Natural Cluster Sizes and the Absence of Large Well-Defined Clusters.”</span> <a href="https://arxiv.org/abs/0810.1355">https://arxiv.org/abs/0810.1355</a>.
</div>
<div id="ref-Lin" class="csl-entry">
Li, Lin, and Daniel L. Sussman. 2019. <span>“Graph Matching via Multi-Scale Heat Diffusion.”</span> In <em>2019 IEEE International Conference on Big Data (Big Data)</em>, 1157–62. <a href="https://doi.org/10.1109/BigData47090.2019.9005526">https://doi.org/10.1109/BigData47090.2019.9005526</a>.
</div>
<div id="ref-ML1" class="csl-entry">
Liu, Zhi-Yong, and Hong Qiao. 2012. <span>“A Convex-Concave Relaxation Procedure Based Subgraph Matching Algorithm.”</span> Edited by Steven C. H. Hoi and Wray Buntine, Proceedings of machine learning research, 25: 237–52. <a href="http://proceedings.mlr.press/v25/liu12a.html">http://proceedings.mlr.press/v25/liu12a.html</a>.
</div>
<div id="ref-FAQ" class="csl-entry">
Lyzinski, V., D. E. Fishkind, M. Fiori, J. T. Vogelstein, C. E. Priebe, and G. Sapiro. 2016. <span>“Graph Matching: Relax at Your Own Risk.”</span> <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em> 38 (1): 60–73. <a href="https://doi.org/10.1109/TPAMI.2015.2424894">https://doi.org/10.1109/TPAMI.2015.2424894</a>.
</div>
<div id="ref-SGM" class="csl-entry">
Lyzinski, Vince, Donniell E. Fishkind, and Carey E. Priebe. 2014. <span>“Seeded Graph Matching for Correlated Erdös-r<span>é</span>nyi Graphs.”</span> <em>J. Mach. Learn. Res.</em> 15 (1): 3513–40. <a href="https://dl.acm.org/doi/10.5555/2627435.2750357">https://dl.acm.org/doi/10.5555/2627435.2750357</a>.
</div>
<div id="ref-row_perm" class="csl-entry">
Lyzinski, Vince, and Daniel Sussman. 2017. <span>“Graph Matching the Matchable Nodes When Some Nodes Are Unmatchable.”</span> In. SIAM Workshop on Network Science.
</div>
<div id="ref-SpecMatch" class="csl-entry">
Mateus, Diana, Radu P. Horaud, David Knossow, Fabio Cuzzolin, and Edmond Boyer. 2008. <span>“Articulated Shape Matching Using Laplacian Eigenfunctions and Unsupervised Point Registration.”</span> In <em>Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition</em>. <a href="http://perception.inrialpes.fr/Publications/2008/MHKCB08/">http://perception.inrialpes.fr/Publications/2008/MHKCB08/</a>.
</div>
<div id="ref-bio3" class="csl-entry">
Nabieva, Elena, Kam Jim, Amit Agarwal, Bernard Chazelle, and Mona Singh. 2005. <span>“Whole-Proteome Prediction of Protein Function via Graph-Theoretic Analysis of Interaction Maps.”</span>
</div>
<div id="ref-SocialNetwork" class="csl-entry">
Narayanan, A., and V. Shmatikov. 2009. <span>“De-Anonymizing Social Networks.”</span> In <em>2009 30th IEEE Symposium on Security and Privacy</em>, 173–87. <a href="https://doi.org/10.1109/SP.2009.22">https://doi.org/10.1109/SP.2009.22</a>.
</div>
<div id="ref-Papadimitriou1998-lz" class="csl-entry">
Papadimitriou, Christos H, and Kenneth Steiglitz. 1998. <em>Combinatorial Optimization: Algorithms and Complexity</em>. Courier Corporation. <a href="https://play.google.com/store/books/details?id=cDY-joeCGoIC">https://play.google.com/store/books/details?id=cDY-joeCGoIC</a>.
</div>
<div id="ref-transportation" class="csl-entry">
Riccardo, Gallotti, and Barthelemy Marc. 2015. <span>“The Multilayer Temporal Network of Public Transport in Great Britain.”</span> <em>Scientific Data</em> 2 (January). <a href="https://doi.org/10.1038/sdata.2014.56">https://doi.org/10.1038/sdata.2014.56</a>.
</div>
<div id="ref-IsoRank" class="csl-entry">
Singh, Rohit, Jinbo Xu, and Bonnie Berger. 2008. <span>“Global Alignment of Multiple Protein Interaction Networks with Application to Functional Orthology Detection.”</span> <em>Proceedings of the National Academy of Sciences</em> 105 (35): 12763–68. <a href="https://doi.org/10.1073/pnas.0806627105">https://doi.org/10.1073/pnas.0806627105</a>.
</div>
<div id="ref-centering" class="csl-entry">
Sussman, Daniel L., Vince Lyzinski, Youngser Park, and Carey E. Priebe. 2018. <span>“<span class="nocase">Matched Filters for Noisy Induced Subgraph Detection</span>.”</span> <em>arXiv e-Prints</em>, March, arXiv:1803.02423. <a href="https://arxiv.org/abs/1803.02423">https://arxiv.org/abs/1803.02423</a>.
</div>
<div id="ref-Umeyama" class="csl-entry">
Umeyama, S. 1988. <span>“An Eigendecomposition Approach to Weighted Graph Matching Problems.”</span> <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em> 10 (5): 695–703. <a href="https://doi.org/10.1109/34.6778">https://doi.org/10.1109/34.6778</a>.
</div>
<div id="ref-Volgenant1996-o" class="csl-entry">
Volgenant, A. 1996. <span>“Linear and Semi-Assignment Problems: A Core Oriented Approach.”</span> <em>Computer and Operations Research</em> 23: 917–32.
</div>
<div id="ref-Percolation" class="csl-entry">
Yartseva, Lyudmila, and Matthias Grossglauser. 2013. <span>“On the Performance of Percolation Graph Matching,”</span> COSN ’13, 119–30. <a href="https://doi.org/10.1145/2512938.2512952">https://doi.org/10.1145/2512938.2512952</a>.
</div>
<div id="ref-rdpg" class="csl-entry">
Young, Stephen J., and Edward R. Scheinerman. 2007. <span>“Random Dot Product Graph Models for Social Networks.”</span> In <em>Proceedings of the 5th International Conference on Algorithms and Models for the Web-Graph</em>, 138–49. WAW’07. Berlin, Heidelberg: Springer-Verlag. <a href="https://dl.acm.org/doi/10.5555/1777879.1777890">https://dl.acm.org/doi/10.5555/1777879.1777890</a>.
</div>
<div id="ref-PATH" class="csl-entry">
Zaslavskiy, M., F. Bach, and J. Vert. 2009. <span>“A Path Following Algorithm for the Graph Matching Problem.”</span> <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em> 31 (12): 2227–42. <a href="https://doi.org/10.1109/TPAMI.2008.245">https://doi.org/10.1109/TPAMI.2008.245</a>.
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
